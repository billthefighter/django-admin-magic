{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django Admin Magic","text":"<p>A simple Django app to automatically register your models with the admin site.</p> <ul> <li>Automatically registers all models from one or more apps</li> <li>Sensible defaults for list display, filters, search, and actions</li> <li>One-line setup from your admin.py</li> <li>Optional auto-discovery across all installed apps</li> <li>First-class support for polymorphic models via django-polymorphic</li> <li>Utilities like linkify for relations, CSV export, and safe pagination</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>Sometimes you just want to browse your data in Django Admin without writing boilerplate admin classes for every model. Django Admin Magic generates admin classes on the fly with good defaults and lets you customize them incrementally when needed.</p>"},{"location":"#quick-install","title":"Quick install","text":"<pre><code>pip install django-admin-magic\n</code></pre> <p>Enable the app: <pre><code>INSTALLED_APPS = [\n    # ...\n    \"django_admin_magic\",\n]\n</code></pre></p> <p>Continue with Getting Started to configure and use the library, or jump to the API Reference.</p>"},{"location":"CI_CD_SETUP/","title":"CI/CD Pipeline Setup","text":"<p>This document explains the GitHub Actions CI/CD pipeline setup for Django Auto Admin.</p>"},{"location":"CI_CD_SETUP/#overview","title":"Overview","text":"<p>The CI/CD pipeline consists of three main workflows:</p> <ol> <li>CI (<code>ci.yml</code>) - Runs on every push and pull request</li> <li>Deploy (<code>deploy.yml</code>) - Runs when a new release is published</li> <li>Update Badges (<code>update-badges.yml</code>) - Runs daily to keep badges current</li> </ol>"},{"location":"CI_CD_SETUP/#ci-workflow","title":"CI Workflow","text":"<p>The CI workflow runs the following jobs:</p>"},{"location":"CI_CD_SETUP/#test-matrix","title":"Test Matrix","text":"<ul> <li>Django versions: 3.2, 4.0, 4.1, 4.2, 5.0</li> <li>Python versions: 3.8, 3.9, 3.10, 3.11, 3.12</li> <li>Exclusions: Django 5.0 with Python 3.8/3.9 (incompatible)</li> </ul>"},{"location":"CI_CD_SETUP/#jobs","title":"Jobs","text":"<ol> <li>test - Runs pytest with coverage across all Django/Python combinations</li> <li>lint - Runs ruff for code formatting and linting</li> <li>security - Runs bandit for security analysis</li> <li>update-badges - Updates coverage and test badges (main branch only)</li> </ol>"},{"location":"CI_CD_SETUP/#deployment-workflow","title":"Deployment Workflow","text":"<p>The deployment workflow: 1. Builds the package using <code>python -m build</code> 2. Validates the package with <code>twine check</code> 3. Publishes to PyPI 4. Optionally publishes to TestPyPI for testing</p>"},{"location":"CI_CD_SETUP/#required-secrets","title":"Required Secrets","text":"<p>To enable full functionality, add these secrets to your GitHub repository:</p>"},{"location":"CI_CD_SETUP/#for-pypi-deployment","title":"For PyPI Deployment","text":"<ul> <li><code>PYPI_API_TOKEN</code> - Your PyPI API token</li> <li><code>TEST_PYPI_API_TOKEN</code> - Your TestPyPI API token (optional)</li> </ul>"},{"location":"CI_CD_SETUP/#for-badge-updates","title":"For Badge Updates","text":"<ul> <li><code>GITHUB_TOKEN</code> - Automatically provided by GitHub Actions</li> </ul>"},{"location":"CI_CD_SETUP/#setting-up-pypi-tokens","title":"Setting Up PyPI Tokens","text":"<ol> <li>Create PyPI Account: Sign up at https://pypi.org/</li> <li>Generate API Token:</li> <li>Go to Account Settings \u2192 API tokens</li> <li>Create a new token with \"Entire account\" scope</li> <li>Copy the token (starts with <code>pypi-</code>)</li> <li>Add to GitHub Secrets:</li> <li>Go to your repository \u2192 Settings \u2192 Secrets and variables \u2192 Actions</li> <li>Add new repository secret named <code>PYPI_API_TOKEN</code></li> <li>Paste your PyPI token</li> </ol>"},{"location":"CI_CD_SETUP/#badge-system","title":"Badge System","text":"<p>The pipeline automatically generates and updates these badges:</p> <ul> <li>Tests: Shows test status (passing/failing)</li> <li>Coverage: Shows code coverage percentage</li> <li>PyPI Version: Shows current package version on PyPI</li> <li>Python Versions: Shows supported Python versions</li> <li>Django Versions: Shows supported Django versions</li> </ul> <p>Badges are stored in <code>.github/badges/</code> and updated: - After successful CI runs on the main branch - Daily via scheduled workflow - Manually via workflow dispatch</p>"},{"location":"CI_CD_SETUP/#local-development","title":"Local Development","text":"<p>To test the CI setup locally:</p> <pre><code># Install development dependencies\npip install -e \".[dev]\"\n\n# Run tests with coverage\npytest --cov=src/django_admin_magic --cov-report=xml --cov-report=term-missing\n\n# Run linting\nruff check .\nruff format --check .\n\n# Run security checks\nbandit -r src/\n\n# Build package (test deployment)\npython -m build\ntwine check dist/*\n</code></pre>"},{"location":"CI_CD_SETUP/#troubleshooting","title":"Troubleshooting","text":""},{"location":"CI_CD_SETUP/#common-issues","title":"Common Issues","text":"<ol> <li>Badge Updates Failing</li> <li>Ensure <code>GITHUB_TOKEN</code> has write permissions</li> <li> <p>Check that the main branch is protected correctly</p> </li> <li> <p>PyPI Deployment Failing</p> </li> <li>Verify <code>PYPI_API_TOKEN</code> is set correctly</li> <li>Ensure package version is incremented in <code>pyproject.toml</code></li> <li> <p>Check that the release tag matches the version</p> </li> <li> <p>Test Matrix Failures</p> </li> <li>Check Django/Python version compatibility</li> <li>Update version exclusions in the matrix if needed</li> </ol>"},{"location":"CI_CD_SETUP/#manual-badge-update","title":"Manual Badge Update","text":"<p>To manually update badges:</p> <ol> <li>Go to Actions tab in GitHub</li> <li>Select \"Update Badges\" workflow</li> <li>Click \"Run workflow\"</li> <li>Select branch and click \"Run workflow\"</li> </ol>"},{"location":"CI_CD_SETUP/#customization","title":"Customization","text":""},{"location":"CI_CD_SETUP/#adding-new-test-environments","title":"Adding New Test Environments","text":"<p>To add new Django or Python versions:</p> <ol> <li>Update the matrix in <code>.github/workflows/ci.yml</code></li> <li>Add any necessary exclusions for incompatible combinations</li> <li>Test locally to ensure compatibility</li> </ol>"},{"location":"CI_CD_SETUP/#adding-new-badges","title":"Adding New Badges","text":"<p>To add new badges:</p> <ol> <li>Generate the badge using appropriate tools</li> <li>Store in <code>.github/badges/</code></li> <li>Update README.md to include the badge</li> <li>Modify CI workflow to generate the badge automatically</li> </ol>"},{"location":"CI_CD_SETUP/#modifying-deployment","title":"Modifying Deployment","text":"<p>To customize deployment:</p> <ol> <li>Edit <code>.github/workflows/deploy.yml</code></li> <li>Add additional validation steps</li> <li>Configure additional deployment targets</li> </ol>"},{"location":"CI_CD_SETUP/#security-considerations","title":"Security Considerations","text":"<ul> <li>API tokens are stored as GitHub secrets</li> <li>Tokens have minimal required permissions</li> <li>Security scanning runs on every CI build</li> <li>Dependencies are cached to reduce attack surface</li> </ul>"},{"location":"CI_CD_SETUP/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Dependencies are cached between runs</li> <li>Matrix builds run in parallel</li> <li>Only necessary jobs run on each trigger</li> <li>Badge updates are batched to reduce API calls </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Django Admin Magic reads settings via the <code>AUTO_ADMIN_</code> prefix. These map to defaults in <code>django_admin_magic.defaults</code>.</p>"},{"location":"configuration/#core-selection","title":"Core selection","text":"<ul> <li>AUTO_ADMIN_APP_LABEL: string or list. App(s) to register. Default: <code>None</code>.</li> <li>AUTO_ADMIN_APP_LABELS: list of app labels. Default: <code>[]</code>.</li> <li>AUTO_ADMIN_AUTO_DISCOVER_ALL_APPS: bool. Discover all installed apps with models. Default: <code>False</code>.</li> <li>AUTO_ADMIN_DISABLED: bool. Global kill switch. Default: <code>False</code>.</li> </ul>"},{"location":"configuration/#safety-and-context","title":"Safety and context","text":"<ul> <li>AUTO_ADMIN_SKIP_COMMANDS: list. Management commands that disable auto-registration (e.g. <code>makemigrations</code>, <code>migrate</code>). Default: <code>[\"makemigrations\", \"migrate\"]</code>.</li> <li>AUTO_ADMIN_SKIP_IF_ADMIN_NOT_INSTALLED: bool. Skip when <code>django.contrib.admin</code> is not in <code>INSTALLED_APPS</code>. Default: <code>True</code>.</li> <li>Env overrides: set <code>DJANGO_ADMIN_MAGIC_DISABLE=1</code> or <code>AUTO_ADMIN_DISABLE=1</code> to disable.</li> </ul>"},{"location":"configuration/#admin-defaults-and-heuristics","title":"Admin defaults and heuristics","text":"<ul> <li>AUTO_ADMIN_DEFAULT_EXCLUDED_TERMS: list of substrings filtered from <code>list_display</code> (e.g. <code>\"_ptr\"</code>, <code>\"uuid\"</code>, <code>\"id\"</code>, <code>\"pk\"</code>, <code>\"search\"</code>).</li> <li>AUTO_ADMIN_DEFAULT_DO_NOT_REGISTER_FILTER_STRING_LIST: model name substrings that prevent registration (e.g. <code>\"Historical\"</code>).</li> <li>AUTO_ADMIN_ADMIN_TUPLE_ATTRIBUTES_TO_LIST: attributes coerced to lists so they can be mutated (default: <code>list_display</code>, <code>list_filter</code>, <code>search_fields</code>, <code>readonly_fields</code>).</li> <li>AUTO_ADMIN_REORDER_LINKIFY_FIELDS: bool. Avoids a linkified field being first in changelist to prevent checkbox conflicts. Default: <code>True</code>.</li> </ul>"},{"location":"configuration/#many-to-many-rendering","title":"Many-to-many rendering","text":"<ul> <li>AUTO_ADMIN_M2M_LIST_ENABLED: bool. Enable M2M fields in changelist with linkified items. Default: <code>True</code>.</li> <li>AUTO_ADMIN_M2M_LIST_MAX_ITEMS: int. Max related objects to display per row before clipping with <code>...</code>. Default: <code>10</code>.</li> <li>AUTO_ADMIN_M2M_LIST_DISPLAY_ATTR: string. Attribute on related object to display. Use <code>\"__str__\"</code> for the string representation. Supports dotted paths (e.g., <code>\"profile.name\"</code>). Default: <code>\"__str__\"</code>.</li> </ul>"},{"location":"configuration/#registrar-helpers","title":"Registrar helpers","text":"<p>You can bypass settings and specify apps directly from <code>admin.py</code> using: <pre><code>from django_admin_magic.utils import (\n    create_auto_admin_registrar,\n    create_auto_admin_registrar_for_apps,\n    create_auto_admin_registrar_for_all_apps,\n)\n</code></pre></p> <p>These utilities respect the same safety checks as settings.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#auto-registration","title":"Auto-registration","text":"<ul> <li>Registers all concrete models in the selected app(s)</li> <li>Skips models whose names contain configured exclusion terms (e.g. <code>Historical</code>)</li> <li>Supports explicit apps, multiple apps, or full auto-discovery</li> </ul>"},{"location":"features/#smart-changelist-defaults","title":"Smart changelist defaults","text":"<ul> <li><code>list_display</code> built from model fields, with exclusions from <code>DEFAULT_EXCLUDED_TERMS</code></li> <li>Relation fields are displayed with clickable links via <code>linkify()</code></li> <li>GenericForeignKeys displayed via <code>linkify_gfk()</code></li> <li>Many-to-many fields rendered as comma-separated, linkified items with clipping (see below)</li> <li>Common filters auto-added for booleans, datetimes, and chars</li> <li>Properties on the model are appended if safe and unique</li> <li>Created/updated timestamp fields moved to end</li> <li>Optional reordering to ensure the first column is not a linkify field</li> </ul>"},{"location":"features/#performance-and-ux-defaults","title":"Performance and UX defaults","text":"<ul> <li>Uses <code>TimeLimitedPaginator</code> to avoid slow count queries</li> <li><code>show_full_result_count = False</code> to prevent expensive COUNT(*)</li> <li><code>list_select_related = True</code> by default to reduce N+1 queries</li> </ul>"},{"location":"features/#polymorphic-model-support","title":"Polymorphic model support","text":"<ul> <li>Detects <code>django-polymorphic</code> and uses:</li> <li><code>PolymorphicParentListAdmin</code> for parent models (with discovered children)</li> <li><code>PolymorphicChildListAdmin</code> for child models</li> </ul>"},{"location":"features/#csv-export-action","title":"CSV export action","text":"<ul> <li>Built-in <code>ExportCsvMixin</code> adds an \"Export Selected to CSV\" action</li> </ul>"},{"location":"features/#runtime-customization-api","title":"Runtime customization API","text":"<ul> <li>Retrieve the live <code>ModelAdmin</code> instance for a model and adjust:</li> <li><code>append_list_display</code>, <code>prepend_list_display</code>, <code>remove_list_display</code></li> <li><code>append_filter_display</code>, <code>add_search_fields</code></li> <li><code>update_list_select_related</code></li> <li><code>append_inline</code></li> <li><code>add_admin_method</code> (actions and display functions)</li> </ul> <p>See Usage for examples.</p>"},{"location":"features/#many-to-many-handling","title":"Many-to-many handling","text":"<ul> <li>Detail view uses Django's default M2M form widget; nothing custom to learn</li> <li>Changelist shows M2M fields as a comma-separated list of related objects</li> <li>Each item links to the related object's admin change page (when registered)</li> <li>Displays up to a configurable limit (default: 10); extra items are clipped with <code>...</code></li> <li>Works with explicit <code>through</code> tables; the end objects are shown</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install django-admin-magic\n</code></pre> <p>Add to <code>INSTALLED_APPS</code>: <pre><code>INSTALLED_APPS = [\n    # ...\n    \"django_admin_magic\",\n]\n</code></pre></p>"},{"location":"getting-started/#quickstart","title":"Quickstart","text":"<p>Register all models for a specific app from its <code>admin.py</code>: <pre><code>from django_admin_magic.utils import create_auto_admin_registrar\n\nregistrar = create_auto_admin_registrar()  # infers current app label\n# or explicitly\n# registrar = create_auto_admin_registrar(\"my_app\")\n</code></pre></p> <p>Register multiple apps: <pre><code>from django_admin_magic.utils import create_auto_admin_registrar_for_apps\n\nregistrar = create_auto_admin_registrar_for_apps([\"app1\", \"app2\"]) \n</code></pre></p> <p>Register all discovered apps that have models: <pre><code>from django_admin_magic.utils import create_auto_admin_registrar_for_all_apps\n\nregistrar = create_auto_admin_registrar_for_all_apps()\n</code></pre></p>"},{"location":"getting-started/#demo-app","title":"Demo app","text":"<p>This repo ships with a full demo: <pre><code>python demo_app/setup_demo.py\npython demo_app/manage.py runserver\n</code></pre> - Main: http://127.0.0.1:8000/ - Admin: http://127.0.0.1:8000/admin/ (login: <code>admin</code> / <code>admin123</code>)</p> <p>See <code>demo_app/README.md</code> for details.</p>"},{"location":"polymorphic/","title":"Polymorphic Models","text":"<p>If <code>django-polymorphic</code> is installed, Django Admin Magic adapts automatically:</p> <ul> <li>Parent models use <code>PolymorphicParentListAdmin</code>, listing the parent and all child types</li> <li>Child models use <code>PolymorphicChildListAdmin</code></li> <li>Child classes are discovered dynamically using Python subclass inspection</li> </ul>"},{"location":"polymorphic/#usage","title":"Usage","text":"<p>No special configuration is required. Register your app(s) normally; the correct admin classes are chosen for you.</p> <pre><code>from django_admin_magic.utils import create_auto_admin_registrar\nregistrar = create_auto_admin_registrar(\"my_app\")\n</code></pre> <p>You can customize list displays, filters, search, and actions the same way as for non-polymorphic models.</p>"},{"location":"usage/","title":"Usage","text":"<p>After creating a registrar, you can customize admin classes at runtime.</p>"},{"location":"usage/#get-the-live-admin-instance-for-a-model","title":"Get the live admin instance for a model","text":"<pre><code>from django.apps import apps\n\nregistrar = apps.get_app_config(\"django_admin_magic\").registrar\nMyModelAdmin = registrar.return_admin_class_for_model(MyModel)\n</code></pre>"},{"location":"usage/#display-columns","title":"Display columns","text":"<p>Append fields to the end: <pre><code>registrar.append_list_display(MyModel, [\"status\", \"created_at\"]) \n</code></pre></p> <p>Prepend fields to the start: <pre><code>registrar.prepend_list_display(MyModel, [\"name\"]) \n</code></pre></p> <p>Remove fields: <pre><code>registrar.remove_list_display(MyModel, [\"obsolete_field\"]) \n</code></pre></p>"},{"location":"usage/#filters-and-search","title":"Filters and search","text":"<pre><code>registrar.append_filter_display(MyModel, [\"is_active\", \"category\"]) \nregistrar.add_search_fields(MyModel, [\"name\", \"description\"]) \n</code></pre>"},{"location":"usage/#query-optimization","title":"Query optimization","text":"<pre><code># Select all FKs\nregistrar.update_list_select_related(MyModel, True)\n# Or specific relationships\nregistrar.update_list_select_related(MyModel, [\"author\", \"category\"]) \n</code></pre>"},{"location":"usage/#adding-admin-methods","title":"Adding admin methods","text":"<p>Add an action: <pre><code>def mark_as_special(modeladmin, request, queryset):\n    queryset.update(is_special=True)\n\nregistrar.add_admin_method(\n    MyModel,\n    \"mark_as_special\",\n    mark_as_special,\n    short_description=\"Mark selected as special\",\n    is_action=True,\n)\n</code></pre></p> <p>Add a display method: <pre><code>def display_upper_name(admin_instance, obj):\n    return obj.name.upper()\n\naction = registrar.add_admin_method(\n    MyModel,\n    \"upper_name\",\n    display_upper_name,\n    short_description=\"Upper name\",\n)\n</code></pre></p> <p>All changes are synced to the live ModelAdmin instance immediately.</p>"},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#linkifyfield_name","title":"linkify(field_name)","text":"<p>Turns a foreign key in <code>list_display</code> into a clickable link to the related object's admin change page. <pre><code>from django_admin_magic.utils import linkify\n\nMyModelAdmin = registrar.return_admin_class_for_model(MyModel)\nMyModelAdmin.list_display += [linkify(\"parent\")]\n</code></pre> - Sets <code>short_description</code> and <code>admin_order_field</code> automatically - Falls back to plain text if the related model is not registered in admin</p>"},{"location":"utilities/#linkify_gfkfield_name","title":"linkify_gfk(field_name)","text":"<p>For <code>GenericForeignKey</code> fields, generates a link to the target object's admin change page when possible, otherwise displays a readable fallback.</p>"},{"location":"utilities/#timelimitedpaginator","title":"TimeLimitedPaginator","text":"<p>A custom paginator that avoids long-running <code>COUNT(*)</code> queries by setting a short statement timeout on PostgreSQL and providing a safe fallback.</p> <p>Configure on your own <code>ModelAdmin</code> if you need it directly: <pre><code>from django_admin_magic.utils import TimeLimitedPaginator\n\nclass MyAdmin(admin.ModelAdmin):\n    paginator = TimeLimitedPaginator\n</code></pre></p> <p>This paginator is also applied by default through the admin mixins.</p>"},{"location":"utilities/#linkify_m2mfield_name","title":"linkify_m2m(field_name)","text":"<p>Render a ManyToMany field in the changelist as a comma-separated list of linkified related objects.</p> <pre><code>from django_admin_magic.utils import linkify_m2m\n\nMyModelAdmin = registrar.return_admin_class_for_model(MyModel)\nMyModelAdmin.list_display += [linkify_m2m(\"tags\")]\n</code></pre> <ul> <li>Respects configuration: <code>AUTO_ADMIN_M2M_LIST_MAX_ITEMS</code>, <code>AUTO_ADMIN_M2M_LIST_DISPLAY_ATTR</code></li> <li>Clips with <code>...</code> when more than the configured limit</li> <li>Works with explicit <code>through</code> models (shows the end objects)</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Auto-generated API documentation powered by mkdocstrings.</p> <p>Select a module from the sidebar to view its reference.</p>"},{"location":"reference/mixins/","title":"mixins","text":""},{"location":"reference/mixins/#django_admin_magic.mixins.AdminDefaultsMixin","title":"<code>AdminDefaultsMixin</code>","text":"<p>Sensible defaults for database queries in admin classes.</p> Source code in <code>src/django_admin_magic/mixins.py</code> <pre><code>class AdminDefaultsMixin:\n    \"\"\"Sensible defaults for database queries in admin classes.\"\"\"\n\n    def __init__(self, model):\n        # logger.info(f\"Initializing AdminDefaultsMixin for {model.__name__}\")\n        self.paginator = TimeLimitedPaginator\n        # self.list_select_related = True\n        self.show_full_result_count = False  # Prevent slow COUNT(*) for \"Show all\" link\n</code></pre>"},{"location":"reference/mixins/#django_admin_magic.mixins.ListAdminMixin","title":"<code>ListAdminMixin</code>","text":"Source code in <code>src/django_admin_magic/mixins.py</code> <pre><code>class ListAdminMixin:\n    def __init__(self, model):\n        \"\"\"\n        Initialize the admin mixin with empty lists for display and filter.\n\n        Args:\n            model: The model this admin class is for\n\n        \"\"\"\n        # After registration, admin classes are instantiated with tuples in these attributes. We want to modify those,\n        # So we need to recast the fields we want to modify as lists.\n        for attr_name in app_settings.ADMIN_TUPLE_ATTRIBUTES_TO_LIST:\n            if not hasattr(self, attr_name) or not getattr(self, attr_name):\n                setattr(self, attr_name, [])\n            else:\n                attr_val = getattr(self, attr_name)\n                if isinstance(attr_val, tuple):\n                    setattr(self, attr_name, list(attr_val))\n\n        self.list_select_related = True\n        self.model = model\n        # Separate relations and GFKs\n        self.relations = []\n        self.generic_foreign_keys = []\n        self.gfk_constituent_fields = set()  # To track fields used by GFKs\n        self.properties = []  # Track properties on the model\n\n        for field in model._meta.get_fields():\n            if isinstance(field, GenericForeignKey):\n                self.generic_foreign_keys.append(field.name)\n                # Store the names of the fields that make up this GFK\n                self.gfk_constituent_fields.add(field.ct_field)\n                self.gfk_constituent_fields.add(field.fk_field)\n            elif field.many_to_one or field.one_to_one or field.many_to_many:\n                self.relations.append(field.name)\n\n        # Find property attributes on the model class\n        for attr_name in dir(model):\n            if attr_name.startswith(\"_\"):\n                continue\n            # Skip 'pk' and 'id' properties\n            if attr_name in (\"pk\", \"id\"):\n                continue\n            if attr_name in (\"relation_fields\", \"non_relation_fields\"):\n                continue\n            try:\n                attr = getattr(model, attr_name)\n                if isinstance(attr, property):\n                    self.properties.append(attr_name)\n            except (AttributeError, TypeError):\n                continue\n\n        # Automatically add search_vector to search_fields if it exists\n        try:\n            model._meta.get_field(\"search_vector\")\n            if \"search_vector\" not in self.search_fields:\n                self.search_fields.append(\"search_vector\")\n            if \"search_vector\" not in self.readonly_fields:\n                self.readonly_fields.append(\"search_vector\")\n        except FieldDoesNotExist:\n            pass  # The model does not have a search_vector field\n\n        # Ensure list_filter is always a list\n        if not hasattr(self, \"list_filter\"):\n            self.list_filter = []\n        elif not isinstance(self.list_filter, list):\n            self.list_filter = list(self.list_filter)\n\n        self.set_changelist_fields()\n\n    def set_changelist_fields(self, fields_at_end_of_list: list[str] | None = None):\n        \"\"\"\n        Set up the list_display and list_filter fields for the admin class.\n\n        Args:\n            fields_at_end_of_list: Optional list of fields to append at the end of list_display\n\n        \"\"\"\n        fields_at_end_of_list = fields_at_end_of_list or []\n        modelfields = self.model._meta.fields\n        logger.debug(\"Starting set_changelist_fields\")\n        logger.debug(f\"Model fields are {modelfields}\")\n\n        # Reset list_display and list_filter to avoid duplicates\n        self.list_display = []\n        self.list_filter = []\n\n        excluded_terms = app_settings.DEFAULT_EXCLUDED_TERMS\n\n        # Add GenericForeignKeys first, using linkify_gfk\n        for gfk_name in self.generic_foreign_keys:\n            if not any(term in gfk_name.casefold() for term in excluded_terms):\n                self.list_display.append(linkify_gfk(gfk_name))\n\n        # Add other fields (non-M2M concrete fields)\n        for field in modelfields:\n            # Skip fields that are part of a GFK we just added\n            if field.name in self.gfk_constituent_fields:\n                continue\n\n            if not any(term in field.name.casefold() for term in excluded_terms):\n                # Hack to filter created at / updated at fields to end of list\n                if \"_at\" in field.name:\n                    if field.name not in fields_at_end_of_list:\n                        fields_at_end_of_list.append(field.name)\n                elif field.name in self.relations:\n                    self.list_display.append(linkify(field.name))\n                else:\n                    self.list_display.append(field.name)\n\n                # Add boolean fields and foreign keys to list_filter by default\n                if isinstance(\n                    field,\n                    models.BooleanField | models.DateTimeField | models.CharField,\n                ):\n                    self.list_filter.append(field.name)\n\n        # Add many-to-many relations (forward only), if enabled\n        try:\n            if getattr(app_settings, \"M2M_LIST_ENABLED\", True):\n                for rel_field in self.model._meta.get_fields():\n                    if getattr(rel_field, \"many_to_many\", False) and not getattr(rel_field, \"auto_created\", False):\n                        if not any(term in rel_field.name.casefold() for term in excluded_terms):\n                            self.list_display.append(linkify_m2m(rel_field.name))\n        except Exception:\n            # If inspection fails, skip M2M enhancement silently\n            pass\n\n        # Add properties to list_display\n        for prop_name in self.properties:\n            if not any(term in prop_name.casefold() for term in excluded_terms):\n                # Only add properties that aren't already in the list\n                if prop_name not in self.list_display:\n                    self.list_display.append(prop_name)\n\n        # Add fields_at_end_of_list only if they're not already in list_display\n        for field in fields_at_end_of_list:\n            if field not in self.list_display:\n                self.list_display.append(field)\n\n        # Apply linkify reordering if enabled\n        if app_settings.REORDER_LINKIFY_FIELDS:\n            self.list_display = reorder_list_display_to_avoid_linkify_first(self.list_display)\n\n        # Ensure export_as_csv action is available\n        if not hasattr(self, \"actions\"):\n            self.actions = []\n        if not isinstance(self.actions, list):\n            self.actions = list(self.actions)\n\n        # Add export_as_csv action if it's not already there\n        if hasattr(self, \"export_as_csv\") and \"export_as_csv\" not in self.actions:\n            self.actions.append(\"export_as_csv\")\n\n        logger.debug(f\"after set_changelist_fields, List display is {self.list_display}\")\n        logger.debug(f\"list_filter is {self.list_filter}\")\n</code></pre>"},{"location":"reference/mixins/#django_admin_magic.mixins.ListAdminMixin.__init__","title":"<code>__init__(model)</code>","text":"<p>Initialize the admin mixin with empty lists for display and filter.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The model this admin class is for</p> required Source code in <code>src/django_admin_magic/mixins.py</code> <pre><code>def __init__(self, model):\n    \"\"\"\n    Initialize the admin mixin with empty lists for display and filter.\n\n    Args:\n        model: The model this admin class is for\n\n    \"\"\"\n    # After registration, admin classes are instantiated with tuples in these attributes. We want to modify those,\n    # So we need to recast the fields we want to modify as lists.\n    for attr_name in app_settings.ADMIN_TUPLE_ATTRIBUTES_TO_LIST:\n        if not hasattr(self, attr_name) or not getattr(self, attr_name):\n            setattr(self, attr_name, [])\n        else:\n            attr_val = getattr(self, attr_name)\n            if isinstance(attr_val, tuple):\n                setattr(self, attr_name, list(attr_val))\n\n    self.list_select_related = True\n    self.model = model\n    # Separate relations and GFKs\n    self.relations = []\n    self.generic_foreign_keys = []\n    self.gfk_constituent_fields = set()  # To track fields used by GFKs\n    self.properties = []  # Track properties on the model\n\n    for field in model._meta.get_fields():\n        if isinstance(field, GenericForeignKey):\n            self.generic_foreign_keys.append(field.name)\n            # Store the names of the fields that make up this GFK\n            self.gfk_constituent_fields.add(field.ct_field)\n            self.gfk_constituent_fields.add(field.fk_field)\n        elif field.many_to_one or field.one_to_one or field.many_to_many:\n            self.relations.append(field.name)\n\n    # Find property attributes on the model class\n    for attr_name in dir(model):\n        if attr_name.startswith(\"_\"):\n            continue\n        # Skip 'pk' and 'id' properties\n        if attr_name in (\"pk\", \"id\"):\n            continue\n        if attr_name in (\"relation_fields\", \"non_relation_fields\"):\n            continue\n        try:\n            attr = getattr(model, attr_name)\n            if isinstance(attr, property):\n                self.properties.append(attr_name)\n        except (AttributeError, TypeError):\n            continue\n\n    # Automatically add search_vector to search_fields if it exists\n    try:\n        model._meta.get_field(\"search_vector\")\n        if \"search_vector\" not in self.search_fields:\n            self.search_fields.append(\"search_vector\")\n        if \"search_vector\" not in self.readonly_fields:\n            self.readonly_fields.append(\"search_vector\")\n    except FieldDoesNotExist:\n        pass  # The model does not have a search_vector field\n\n    # Ensure list_filter is always a list\n    if not hasattr(self, \"list_filter\"):\n        self.list_filter = []\n    elif not isinstance(self.list_filter, list):\n        self.list_filter = list(self.list_filter)\n\n    self.set_changelist_fields()\n</code></pre>"},{"location":"reference/mixins/#django_admin_magic.mixins.ListAdminMixin.set_changelist_fields","title":"<code>set_changelist_fields(fields_at_end_of_list=None)</code>","text":"<p>Set up the list_display and list_filter fields for the admin class.</p> <p>Parameters:</p> Name Type Description Default <code>fields_at_end_of_list</code> <code>list[str] | None</code> <p>Optional list of fields to append at the end of list_display</p> <code>None</code> Source code in <code>src/django_admin_magic/mixins.py</code> <pre><code>def set_changelist_fields(self, fields_at_end_of_list: list[str] | None = None):\n    \"\"\"\n    Set up the list_display and list_filter fields for the admin class.\n\n    Args:\n        fields_at_end_of_list: Optional list of fields to append at the end of list_display\n\n    \"\"\"\n    fields_at_end_of_list = fields_at_end_of_list or []\n    modelfields = self.model._meta.fields\n    logger.debug(\"Starting set_changelist_fields\")\n    logger.debug(f\"Model fields are {modelfields}\")\n\n    # Reset list_display and list_filter to avoid duplicates\n    self.list_display = []\n    self.list_filter = []\n\n    excluded_terms = app_settings.DEFAULT_EXCLUDED_TERMS\n\n    # Add GenericForeignKeys first, using linkify_gfk\n    for gfk_name in self.generic_foreign_keys:\n        if not any(term in gfk_name.casefold() for term in excluded_terms):\n            self.list_display.append(linkify_gfk(gfk_name))\n\n    # Add other fields (non-M2M concrete fields)\n    for field in modelfields:\n        # Skip fields that are part of a GFK we just added\n        if field.name in self.gfk_constituent_fields:\n            continue\n\n        if not any(term in field.name.casefold() for term in excluded_terms):\n            # Hack to filter created at / updated at fields to end of list\n            if \"_at\" in field.name:\n                if field.name not in fields_at_end_of_list:\n                    fields_at_end_of_list.append(field.name)\n            elif field.name in self.relations:\n                self.list_display.append(linkify(field.name))\n            else:\n                self.list_display.append(field.name)\n\n            # Add boolean fields and foreign keys to list_filter by default\n            if isinstance(\n                field,\n                models.BooleanField | models.DateTimeField | models.CharField,\n            ):\n                self.list_filter.append(field.name)\n\n    # Add many-to-many relations (forward only), if enabled\n    try:\n        if getattr(app_settings, \"M2M_LIST_ENABLED\", True):\n            for rel_field in self.model._meta.get_fields():\n                if getattr(rel_field, \"many_to_many\", False) and not getattr(rel_field, \"auto_created\", False):\n                    if not any(term in rel_field.name.casefold() for term in excluded_terms):\n                        self.list_display.append(linkify_m2m(rel_field.name))\n    except Exception:\n        # If inspection fails, skip M2M enhancement silently\n        pass\n\n    # Add properties to list_display\n    for prop_name in self.properties:\n        if not any(term in prop_name.casefold() for term in excluded_terms):\n            # Only add properties that aren't already in the list\n            if prop_name not in self.list_display:\n                self.list_display.append(prop_name)\n\n    # Add fields_at_end_of_list only if they're not already in list_display\n    for field in fields_at_end_of_list:\n        if field not in self.list_display:\n            self.list_display.append(field)\n\n    # Apply linkify reordering if enabled\n    if app_settings.REORDER_LINKIFY_FIELDS:\n        self.list_display = reorder_list_display_to_avoid_linkify_first(self.list_display)\n\n    # Ensure export_as_csv action is available\n    if not hasattr(self, \"actions\"):\n        self.actions = []\n    if not isinstance(self.actions, list):\n        self.actions = list(self.actions)\n\n    # Add export_as_csv action if it's not already there\n    if hasattr(self, \"export_as_csv\") and \"export_as_csv\" not in self.actions:\n        self.actions.append(\"export_as_csv\")\n\n    logger.debug(f\"after set_changelist_fields, List display is {self.list_display}\")\n    logger.debug(f\"list_filter is {self.list_filter}\")\n</code></pre>"},{"location":"reference/mixins/#django_admin_magic.mixins.PolymorphicParentListAdmin","title":"<code>PolymorphicParentListAdmin</code>","text":"<p>               Bases: <code>PolymorphicParentModelAdmin</code>, <code>ListAdminMixin</code>, <code>AdminDefaultsMixin</code></p> Source code in <code>src/django_admin_magic/mixins.py</code> <pre><code>class PolymorphicParentListAdmin(PolymorphicParentModelAdmin, ListAdminMixin, AdminDefaultsMixin):\n    def __init__(self, model, admin_site=None):\n        self.base_model = model\n        self.child_models = (model, *tuple(get_all_child_classes(model)))\n        ListAdminMixin.__init__(self, model)\n        PolymorphicParentModelAdmin.__init__(self, model=model, admin_site=admin_site)\n        AdminDefaultsMixin.__init__(self, model)\n\n    def get_child_models(self):\n        \"\"\"Return child models for this admin.\"\"\"\n        return self.child_models\n</code></pre>"},{"location":"reference/mixins/#django_admin_magic.mixins.PolymorphicParentListAdmin.get_child_models","title":"<code>get_child_models()</code>","text":"<p>Return child models for this admin.</p> Source code in <code>src/django_admin_magic/mixins.py</code> <pre><code>def get_child_models(self):\n    \"\"\"Return child models for this admin.\"\"\"\n    return self.child_models\n</code></pre>"},{"location":"reference/registrar/","title":"registrar","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar","title":"<code>AdminModelRegistrar</code>","text":"<p>Class that handles the registration and configuration of Django admin classes for models.</p> <p>This class provides a centralized way to register models with the Django admin site and manage their display properties (list_display, list_filter, etc.). It handles both regular Django models and polymorphic models.</p> <p>General flow: 1. create prototype models (_admin_class_factory) 2. register models (register_models)     2.1. set defaults for fields to show up in admin(init method of listadmin mixin) 3. Modify fields with append methods once admin classes have been registered.</p>"},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--note-this-needs-a-fundamentally-different-approach-the-sync-idea-is-good-because","title":"NOTE: This needs a fundamentally different approach. The Sync() idea is good, because","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--we-need-to-make-sure-the-instances-and-the-adminclasses-actually-have-the-same","title":"we need to make sure the instances and the adminclasses actually have the same","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--attributes-or-you-get-errors-like-this","title":"attributes or you get errors like this:","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--admine108-the","title":": (admin.E108) The","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--value-of-list_display5-refers-to-created_at-which-is-not-a-callable-an","title":"value of 'list_display[5]' refers to 'created_at', which is not a callable, an","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--attribute-of-adminclass_projectalternatename-or-an-attribute-or-method-on","title":"attribute of 'AdminClass_ProjectAlternateName', or an attribute or method on","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--project_trackerprojectalternatename","title":"'project_tracker.ProjectAlternateName'.","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--as-of-right-now-this-commit-all-edits-using-the-methods-for-the-registrar-are","title":"As of right now (this commit) all edits using the methods for the registrar are","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--happenin-on-the-widget-not-the-admin-class","title":"happenin on the widget, not the admin class.","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--they-need-to-be-syncd-and-the-sync-code-needs-to-be-updated-to-sync-changes-from","title":"They need to be syncd! And the sync code needs to be updated to sync changes from","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar--the-instance-to-the-admin-class-prototype","title":"the instance to the admin class prototype.  Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>class AdminModelRegistrar:\n    \"\"\"\n    Class that handles the registration and configuration of Django admin classes for models.\n\n    This class provides a centralized way to register models with the Django admin site and\n    manage their display properties (list_display, list_filter, etc.). It handles both regular\n    Django models and polymorphic models.\n\n    General flow:\n    1. create prototype models (_admin_class_factory)\n    2. register models (register_models)\n        2.1. set defaults for fields to show up in admin(__init__ method of listadmin mixin)\n    3. Modify fields with append methods once admin classes have been registered.\n    #NOTE: This needs a fundamentally different approach. The Sync() idea is good, because\n    # we need to make sure the instances and the adminclasses actually have the same\n    # attributes or you get errors like this:\n    # &lt;class 'django.forms.widgets.AdminClass_ProjectAlternateName'&gt;: (admin.E108) The\n    # value of 'list_display[5]' refers to 'created_at', which is not a callable, an\n    # attribute of 'AdminClass_ProjectAlternateName', or an attribute or method on\n    # 'project_tracker.ProjectAlternateName'.\n    # As of right now (this commit) all edits using the methods for the registrar are\n    # happenin on the widget, not the admin class.\n    # They need to be syncd! And the sync code needs to be updated to sync changes from\n    # the instance to the admin class prototype.\n    \"\"\"\n\n    def __init__(self, app_label: str | None = None, app_labels: list[str] | None = None, auto_discover: bool = False):\n        \"\"\"\n        Initialize the registrar for specific Django app(s).\n\n        Args:\n            app_label (str, optional): The label of a single Django app to register models for.\n            app_labels (List[str], optional): List of Django app labels to register models for.\n            auto_discover (bool): Whether to auto-discover and register all installed apps.\n\n        \"\"\"\n        self.class_dict: dict[str, tuple[InclusiveModelType, AdminClassType]] = {}\n        self.app_labels = self._determine_app_labels(app_label, app_labels, auto_discover)\n        self.do_not_register_filter_string_list = app_settings.DEFAULT_DO_NOT_REGISTER_FILTER_STRING_LIST\n        self.models = []\n        self._collect_models()\n        self.model_iterator()\n        self.register_models()\n\n    def _determine_app_labels(\n        self, app_label: str | None, app_labels: list[str] | None, auto_discover: bool\n    ) -&gt; list[str]:\n        \"\"\"\n        Determine which app labels to use based on the provided parameters and settings.\n\n        Priority order:\n        1. Explicitly provided app_label or app_labels\n        2. Settings configuration (APP_LABEL, APP_LABELS, AUTO_DISCOVER_ALL_APPS)\n        3. Auto-discovery if enabled\n        \"\"\"\n        # If explicit parameters are provided, use them\n        if app_label:\n            return [app_label]\n        if app_labels:\n            return app_labels\n\n        # Check settings\n        if hasattr(app_settings, \"APP_LABEL\") and app_settings.APP_LABEL:\n            if isinstance(app_settings.APP_LABEL, list):\n                return app_settings.APP_LABEL\n            return [app_settings.APP_LABEL]\n\n        if hasattr(app_settings, \"APP_LABELS\") and app_settings.APP_LABELS:\n            return app_settings.APP_LABELS\n\n        # Auto-discovery\n        if auto_discover or (hasattr(app_settings, \"AUTO_DISCOVER_ALL_APPS\") and app_settings.AUTO_DISCOVER_ALL_APPS):\n            return self._discover_app_labels()\n\n        # Default to empty list if nothing is configured\n        return []\n\n    def _discover_app_labels(self) -&gt; list[str]:\n        \"\"\"\n        Discover all Django apps that have models.\n\n        Returns:\n            List of app labels that have models.\n\n        \"\"\"\n        discovered_apps = []\n        for app_config in apps.get_app_configs():\n            # Skip django_admin_magic itself and other Django system apps\n            if app_config.label in [\"django_admin_magic\", \"admin\", \"auth\", \"contenttypes\", \"sessions\"]:\n                continue\n\n            # Check if the app has any models\n            models_in_app = list(app_config.get_models())\n            if len(models_in_app) &gt; 0:\n                discovered_apps.append(app_config.label)\n                logger.info(f\"Auto-discovered app: {app_config.label} with {len(models_in_app)} models\")\n            else:\n                # Empty apps during auto-discovery are normal; log at INFO to avoid noisy warnings\n                logger.info(f\"Auto-discovery: app '{app_config.label}' has no models; skipping\")\n\n        return discovered_apps\n\n    def _collect_models(self):\n        \"\"\"Collect all models from the specified app labels.\"\"\"\n        for app_label in self.app_labels:\n            try:\n                app_config = apps.get_app_config(app_label=app_label)\n                app_models = list(app_config.get_models())\n                self.models.extend(app_models)\n                if len(app_models) == 0:\n                    logger.warning(f\"App '{app_label}' has no models; skipping\")\n                else:\n                    logger.info(f\"Collected {len(app_models)} models from app: {app_label}\")\n            except LookupError:\n                logger.warning(f\"App '{app_label}' not found in installed apps\")\n\n    @classmethod\n    def register_all_discovered_apps(cls) -&gt; \"AdminModelRegistrar\":\n        \"\"\"\n        Class method to create a registrar that auto-discovers and registers all apps.\n\n        This is useful for users who want to register all their models automatically\n        without specifying individual app labels.\n\n        Returns:\n            AdminModelRegistrar instance configured for auto-discovery\n\n        \"\"\"\n        return cls(auto_discover=True)\n\n    @classmethod\n    def register_apps(cls, app_labels: list[str]) -&gt; \"AdminModelRegistrar\":\n        \"\"\"\n        Class method to create a registrar for specific app labels.\n\n        Args:\n            app_labels: List of app labels to register\n\n        Returns:\n            AdminModelRegistrar instance configured for the specified apps\n\n        \"\"\"\n        return cls(app_labels=app_labels)\n\n    @classmethod\n    def register_app(cls, app_label: str) -&gt; \"AdminModelRegistrar\":\n        \"\"\"\n        Class method to create a registrar for a single app.\n\n        Args:\n            app_label: The app label to register\n\n        Returns:\n            AdminModelRegistrar instance configured for the specified app\n\n        \"\"\"\n        return cls(app_label=app_label)\n\n    def model_iterator(self):\n        \"\"\"\n        Iterates through models and creates the associated admin class.\n        Convenience method to create admin classes for models without\n        having to explicitly create them in each app's admin.py file.\n        \"\"\"\n        for model in self.models:\n            model_name = model.__name__ if isinstance(model, type) else model.__class__.__name__\n            model_passes_filter = not any(x in model_name for x in self.do_not_register_filter_string_list)\n            if model._meta.abstract is False and model_passes_filter:\n                admin_class = self._admin_class_factory(model, admin.site)\n                self.class_dict[str(model)] = (model, admin_class)\n\n    def _admin_class_factory(self, model, admin_site):\n        \"\"\"Creates class prototypes for admin_classes depending on the incoming model object.\"\"\"\n        adminclass_name = f\"AdminClass_{model.__name__}\"\n        common_class_kwargs = {\"model\": model, \"admin_site\": admin_site}\n        return type(\n            adminclass_name,\n            (ListAdmin,),\n            common_class_kwargs,\n        )\n\n    def _tuple_list_handler(self, tuple_or_list: list[Any] | tuple[Any, ...]) -&gt; list[Any]:\n        \"\"\"\n        Convert a tuple or list to a list, preserving order and removing duplicates.\n\n        This method ensures consistent handling of list-like objects by:\n        1. Converting tuples to lists\n        2. Removing duplicate entries while preserving order\n        3. Handling nested structures recursively\n\n        Args:\n            tuple_or_list: The input tuple or list to process\n\n        Returns:\n            A list with duplicates removed while preserving order\n\n        \"\"\"\n        if isinstance(tuple_or_list, tuple):\n            tuple_or_list = list(tuple_or_list)\n        return list(dict.fromkeys(tuple_or_list))\n\n    def _verify_list_display_in_model(\n        self,\n        model: InclusiveModelType,\n        list_display: list[str] | tuple[str],\n        admin_class: admin.ModelAdmin,\n    ):\n        \"\"\"\n        Verify that all fields in list_display exist on the model or the admin class.\n\n        This method checks both model fields and attributes (including properties)\n        to ensure that all display fields are valid. It handles:\n        1. Field names that exist on the model\n        2. Property names that exist on the model\n        3. Method names that exist on the model\n        4. Callable objects (like linkify or custom display methods)\n        5. Single character strings (used for formatting)\n\n        Args:\n            model: The model to verify fields against\n            list_display: The list of fields to verify\n            admin_class: The admin class associated with the model\n\n        Raises:\n            FieldDoesNotExist: If a field is not found on the model and doesn't match any valid pattern\n\n        \"\"\"\n        # Cast model to appropriate type\n        model_class = cast(\n            \"type[models.Model | PolymorphicModel]\",\n            model if isinstance(model, type) else model.__class__,\n        )\n        model_fields = [field.name for field in model_class._meta.fields]\n        model_attributes = dir(model_class)\n        # Get attributes from the admin class as well\n        admin_class_attributes = dir(admin_class)\n\n        for field in list_display:\n            # Skip validation for:\n            # 1. Callable objects (custom display methods)\n            # 2. Single character strings (often used for formatting)\n            # 3. Fields that have a short_description (admin display methods)\n            if callable(field) or (isinstance(field, str) and len(field) == 1) or hasattr(field, \"short_description\"):\n                continue\n\n            # Check if the field exists on the model OR the admin class\n            if field not in model_fields and field not in model_attributes and field not in admin_class_attributes:\n                if isinstance(field, str):\n                    admin_class_name = getattr(admin_class, \"__name__\", f\"AdminClass_{model_class.__name__}\")\n                    msg = (\n                        f\"Field {field} not found in model {model_class.__name__} or admin class {admin_class_name}\\n\"\n                        f\"Model fields: {model_fields}\\n\"\n                        f\"Model attributes: {model_attributes}\\n\"\n                        f\"Admin class attributes: {admin_class_attributes}\\n\"\n                        f\"List display: {list_display}\"\n                    )\n                    raise FieldDoesNotExist(\n                        msg,\n                    )\n                admin_class_name = getattr(admin_class, \"__name__\", f\"AdminClass_{model_class.__name__}\")\n                logger.debug(\n                    f\"Field {field} not found in model {model_class.__name__} or admin class {admin_class_name}\",\n                )\n\n    def _sync_admin_instance(self, model: InclusiveModelType) -&gt; None:\n        \"\"\"\n        Sync the admin class with its registered instance.\n\n        This method ensures that any changes made to the admin class prototype\n        are reflected in the registered instance. This includes:\n        - list_display\n        - list_filter\n        - inlines\n        - actions\n        - methods and their attributes\n        - search fields\n        - custom querysets\n\n\n        Args:\n            model: The model whose admin class needs to be synced\n\n        \"\"\"\n        admin_class = self.return_admin_class_for_model(model)\n        # Get the actual model class if we were passed an instance\n        model_class = cast(\"type[models.Model]\", model if isinstance(model, type) else model.__class__)\n        registered_instance = admin.site._registry.get(model_class)\n\n        if not registered_instance:\n            return\n\n        # Sync list_display\n        if hasattr(admin_class, \"list_display\"):\n            # Convert list_display to list and filter out any function objects\n            list_display = []\n            for item in admin_class.list_display:\n                if callable(item) and not isinstance(item, type):\n                    # For callable items (methods), create a wrapper that preserves attributes\n                    def create_wrapper(method):\n                        def wrapper(*args, **kwargs):\n                            return method(*args, **kwargs)\n\n                        # Copy all attributes from the original method\n                        for attr in dir(method):\n                            if not attr.startswith(\"_\"):\n                                try:\n                                    setattr(wrapper, attr, getattr(method, attr))\n                                except (AttributeError, TypeError):\n                                    continue\n                        # Copy special attributes if they exist\n                        if hasattr(method, \"__func__\"):\n                            wrapper.__func__ = method.__func__\n                        if hasattr(method, \"__self__\"):\n                            wrapper.__self__ = method.__self__\n                        return wrapper\n\n                    list_display.append(create_wrapper(item))\n                else:\n                    list_display.append(item)\n            registered_instance.list_display = list_display\n\n        # Sync list_filter\n        if hasattr(admin_class, \"list_filter\"):\n            registered_instance.list_filter = admin_class.list_filter\n\n        # Sync search_fields\n        if hasattr(admin_class, \"search_fields\"):\n            registered_instance.search_fields = admin_class.search_fields\n\n        # Sync readonly_fields\n        if hasattr(admin_class, \"readonly_fields\"):\n            registered_instance.readonly_fields = admin_class.readonly_fields\n\n        # Sync list_select_related\n        if hasattr(admin_class, \"list_select_related\"):\n            registered_instance.list_select_related = admin_class.list_select_related\n\n        # Sync inlines\n        if hasattr(admin_class, \"inlines\"):\n            if isinstance(admin_class.inlines, tuple):\n                registered_instance.inlines = list(admin_class.inlines)\n            else:\n                registered_instance.inlines = admin_class.inlines\n\n        # Sync actions\n        if hasattr(admin_class, \"actions\"):\n            current_actions = []\n            if hasattr(registered_instance, \"actions\") and registered_instance.actions is not None:\n                # Start with existing actions from the registered instance\n                current_actions = list(registered_instance.actions)\n\n            admin_actions_to_add = []\n            if admin_class.actions is not None:\n                # Get actions defined on the admin class prototype\n                admin_actions_to_add = list(admin_class.actions)\n\n            # Add actions from the admin class prototype if they aren't already present\n            # in the registered instance's actions list. We compare by name for callables.\n            for action in admin_actions_to_add:\n                action_name = action if isinstance(action, str) else getattr(action, \"__name__\", str(action))\n                is_present = False\n                for existing_action in current_actions:\n                    existing_action_name = (\n                        existing_action\n                        if isinstance(existing_action, str)\n                        else getattr(existing_action, \"__name__\", str(existing_action))\n                    )\n                    if action_name == existing_action_name:\n                        is_present = True\n                        break\n                if not is_present:\n                    # Append the original action (callable or string)\n                    current_actions.append(action)\n\n            # Assign the updated list back to the registered instance\n            registered_instance.actions = current_actions\n\n        # Sync methods and their attributes\n        for attr_name in dir(admin_class):\n            if not attr_name.startswith(\"_\"):  # Skip private methods\n                try:\n                    attr = getattr(admin_class, attr_name)\n                    if callable(attr) and not isinstance(attr, type):\n                        # Create a wrapper function that will have the attributes\n                        def create_wrapper(method):\n                            def wrapper(*args, **kwargs):\n                                return method(*args, **kwargs)\n\n                            # Copy all attributes from the original method\n                            for method_attr in dir(method):\n                                if not method_attr.startswith(\"_\"):\n                                    try:\n                                        setattr(\n                                            wrapper,\n                                            method_attr,\n                                            getattr(method, method_attr),\n                                        )\n                                    except (AttributeError, TypeError):\n                                        continue\n                            # Copy special attributes if they exist\n                            if hasattr(method, \"__func__\"):\n                                wrapper.__func__ = method.__func__\n                            if hasattr(method, \"__self__\"):\n                                wrapper.__self__ = method.__self__\n                            return wrapper\n\n                        wrapped = create_wrapper(attr)\n                        # Set the wrapped method on the instance\n                        setattr(registered_instance, attr_name, wrapped)\n                except (AttributeError, TypeError):\n                    # Skip any attributes that can't be accessed or copied\n                    continue\n\n    def update_list_select_related(\n        self,\n        model: InclusiveModelType,\n        list_select_related: list[str] | tuple[str, ...] | bool,\n    ) -&gt; None:\n        \"\"\"\n        Update the list_select_related property for a model's admin class.\n\n        This method allows setting the list_select_related property to optimize\n        database queries for the admin changelist view. It can be:\n        - True: Select all foreign key relationships\n        - False: Don't use any JOINs\n        - List/tuple of field names: Only JOIN the specified relationships\n\n        Args:\n            model: The model whose admin class should be updated\n            list_select_related: The value to set for list_select_related\n\n        Example:\n            # To select all foreign keys\n            registrar.update_list_select_related(MyModel, True)\n\n            # To select specific foreign keys\n            registrar.update_list_select_related(MyModel, ['author', 'category'])\n\n            # To disable all automatic JOINs\n            registrar.update_list_select_related(MyModel, False)\n\n        \"\"\"\n        admin_class = self.return_admin_class_for_model(model)\n        admin_class.list_select_related = list_select_related\n        self._sync_admin_instance(model)\n\n    def add_admin_method(\n        self,\n        model: InclusiveModelType,\n        method_name: str,\n        method_func: Callable,\n        *,\n        short_description: str | None = None,\n        is_action: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Add a method to the admin class for a model.\n\n        This method allows adding custom methods to the admin class, optionally\n        marking them as actions and setting their short descriptions.\n\n        Args:\n            model: The model to add the method to\n            method_name: The name to give the method\n            method_func: The method to add (should be a function)\n            short_description: Optional description for the method in admin interface\n            is_action: Whether to add this method to the actions list\n\n        Example:\n            def mark_as_special(modeladmin, request, queryset):\n                queryset.update(is_special=True)\n\n            registrar.add_admin_method(\n                MyModel,\n                \"mark_as_special\",\n                mark_as_special,\n                short_description=\"Mark selected items as special\",\n                is_action=True\n            )\n\n        \"\"\"\n        # Validate method_name\n        if not method_name or not isinstance(method_name, str):\n            raise ValueError(\"method_name must be a non-empty string\")\n\n        # Validate method_func\n        if method_func is None:\n            raise ValueError(\"method_func cannot be None\")\n\n        # Validate method_name format (should be a valid Python identifier)\n        if not method_name.replace(\"_\", \"\").isalnum() or method_name[0].isdigit():\n            raise ValueError(\"method_name must be a valid Python identifier\")\n\n        admin_instance = self.return_admin_class_for_model(model)  # This is the actual live instance\n\n        final_wrapped_method: Callable\n        if is_action:\n            # Wrapper for admin actions\n            # method_func signature: (modeladmin_instance, request, queryset)\n            # Django calls action as: func(modeladmin, request, queryset)\n            # This wrapper ensures the original method_func is called correctly.\n            def action_wrapper(modeladmin_param, request_param, queryset_param):\n                return method_func(modeladmin_param, request_param, queryset_param)\n\n            final_wrapped_method = action_wrapper\n        else:\n            # Wrapper for display methods (e.g., in list_display)\n            # method_func signature: (modeladmin_instance, model_instance)\n            # Django calls display method as: admin_instance.method_name(model_instance)\n            # 'admin_instance' (the live model admin instance) is available from the outer scope.\n            def display_wrapper(obj_param):  # obj_param is the model_instance passed by Django\n                # admin_instance is the ModelAdmin instance captured from the outer scope of add_admin_method\n                return method_func(admin_instance, obj_param)\n\n            final_wrapped_method = display_wrapper\n\n        # Set the wrapped method directly on the admin instance\n        setattr(admin_instance, method_name, final_wrapped_method)\n\n        # Set short description if provided (on the final_wrapped_method)\n        if short_description:\n            try:\n                final_wrapped_method.short_description = short_description\n            except AttributeError:\n                logger.warning(f\"Could not set short_description on wrapped method {method_name} for model {model}\")\n\n        # Add to actions if requested\n        if is_action:\n            existing_actions = list(getattr(admin_instance, \"actions\", []) or [])\n            action_to_add = final_wrapped_method  # Add the callable wrapper\n\n            already_present = False\n            for existing_action in existing_actions:\n                if existing_action == action_to_add:\n                    already_present = True\n                    break\n                # Compare by name if functions are different instances but represent the same action\n                if hasattr(existing_action, \"__name__\") and existing_action.__name__ == getattr(\n                    action_to_add,\n                    \"__name__\",\n                    None,\n                ):\n                    already_present = True\n                    break\n\n            if not already_present:\n                existing_actions.append(action_to_add)\n            admin_instance.actions = existing_actions\n\n        # Sync the changes to the registered instance\n        self._sync_admin_instance(model)\n\n    def register_models(self):\n        \"\"\"\n        Register models with the Django admin site.\n\n        This method handles the registration process for all models in the app.\n        It ensures that:\n        1. Each model gets the correct admin class type (regular or polymorphic)\n        2. List display and filter properties are properly initialized\n        \"\"\"\n        if not self.class_dict:\n            logger.debug(f\"No admin classes to register for app {self.app_labels}\")\n            return\n\n        # Ensure any explicit app admin.py registrations are loaded first\n        try:\n            from django.contrib.admin import autodiscover as admin_autodiscover\n\n            admin_autodiscover()\n        except Exception:\n            # Autodiscover may be already executed or unavailable in certain contexts\n            pass\n\n        for name, model_adminclass_tuple in self.class_dict.items():\n            logger.debug(f\"Registering model {name}\")\n            model, admin_class = model_adminclass_tuple\n            # Skip registration if already registered by third-party/admin.py\n            try:\n                if admin.site.is_registered(model):  # type: ignore[attr-defined]\n                    logger.info(f\"Model {model} already registered; skipping auto-registration\")\n                    self._sync_admin_instance(model)\n                    continue\n            except Exception:\n                # Fallback to trying and catching AlreadyRegistered\n                pass\n\n            try:\n                admin.site.register(model, admin_class)  # type: ignore\n                self._sync_admin_instance(model)\n            except AlreadyRegistered:\n                # If already registered, sync the instance\n                self._sync_admin_instance(model)\n\n    def add_search_fields(\n        self,\n        model: InclusiveModelType,\n        search_fields: list[str],\n    ):\n        admin_class = self.return_admin_class_for_model(model)\n        if hasattr(admin_class, \"search_fields\"):\n            # Pass admin_class to verification\n            self._verify_list_display_in_model(model, search_fields, admin_class)\n            admin_class.search_fields = search_fields  # type: ignore\n            self._sync_admin_instance(model)  # Sync after modification\n\n    def append_list_display(\n        self,\n        model: InclusiveModelType,\n        list_display: list[str] | tuple[str],\n    ) -&gt; None:\n        \"\"\"\n        Add fields to the end of the admin display list.\n\n        This method:\n        1. Validates that all fields exist on the model\n        2. Maintains field order while preventing duplicates\n        3. Updates both the admin class and registered instance\n\n        Args:\n            model: The model to modify the admin display for\n            list_display: Fields to add to the display list\n\n        \"\"\"\n        admin_class = self.return_admin_class_for_model(model)\n        if hasattr(admin_class, \"list_display\"):\n            # Pass admin_class to verification\n            self._verify_list_display_in_model(model, list_display, admin_class)\n            current_list = self._tuple_list_handler(admin_class.list_display)\n            # Add new fields, avoiding duplicates\n            for field in list_display:\n                if field not in current_list:\n                    current_list.append(field)\n            admin_class.list_display = current_list\n            self._sync_admin_instance(model)\n\n    def prepend_list_display(\n        self,\n        model: InclusiveModelType,\n        list_display: str | list[str] | tuple[str],\n    ) -&gt; None:\n        \"\"\"\n        Add fields to the start of the admin display list.\n\n        This method:\n        1. Validates that all fields exist on the model\n        2. Removes any existing instances of the fields\n        3. Prepends fields to the start of the list\n        4. Updates both the admin class and registered instance\n\n        Args:\n            model: The model to modify the admin display for\n            list_display: Field(s) to add to the start of the display list.\n                         Can be a single string or list/tuple of strings.\n\n        \"\"\"\n        admin_class = self.return_admin_class_for_model(model)\n        if hasattr(admin_class, \"list_display\"):\n            # Convert single string to list\n            fields_to_add = [list_display] if isinstance(list_display, str) else list(list_display)\n\n            # Pass admin_class to verification\n            self._verify_list_display_in_model(model, fields_to_add, admin_class)\n            current_list = self._tuple_list_handler(admin_class.list_display)\n\n            # Remove any existing instances of the fields\n            for field in fields_to_add:\n                if field in current_list:\n                    current_list.remove(field)\n\n            # Add new fields at the start\n            for field in reversed(fields_to_add):\n                current_list.insert(0, field)\n\n            admin_class.list_display = current_list\n            self._sync_admin_instance(model)\n\n    def remove_list_display(\n        self,\n        model: InclusiveModelType,\n        list_display_to_remove: list[str] | tuple[str],\n    ) -&gt; None:\n        admin_class = self.return_admin_class_for_model(model)\n        admin_class.list_display = [field for field in admin_class.list_display if field not in list_display_to_remove]\n        self._sync_admin_instance(model)\n\n    def append_filter_display(\n        self,\n        model: type[models.Model] | models.Model | PolymorphicModelBase,\n        list_filter: list[str] | tuple[str],\n    ) -&gt; None:\n        \"\"\"\n        Add filter fields to the admin display.\n\n        This method adds fields to the list_filter property of the admin class.\n        It follows the same pattern as list_display management:\n        1. Validates fields exist on the model\n        2. Maintains field order while preventing duplicates\n        3. Updates both admin class and registered instance\n\n        Args:\n            model: The model to add filters to\n            list_filter: List or tuple of field names to add as filters\n\n        Raises:\n            KeyError: If model not found in registered classes\n            FieldDoesNotExist: If field doesn't exist on model\n\n        \"\"\"\n        admin_class = self.return_admin_class_for_model(model)\n        if hasattr(admin_class, \"list_filter\"):\n            # Pass admin_class to verification (assuming list_filter items should also be valid fields/methods)\n            self._verify_list_display_in_model(model, list_filter, admin_class)\n            admin_class.list_filter = self._tuple_list_handler(admin_class.list_filter)\n            # Ensure no duplicates are added\n            for item in list_filter:\n                if item not in admin_class.list_filter:\n                    admin_class.list_filter.append(item)\n            self._sync_admin_instance(model)\n\n    def return_admin_class_for_model(self, model: InclusiveModelType):\n        \"\"\"\n        Return the admin class for a model.\n\n        This method retrieves the admin class associated with a model from the\n        class dictionary. It handles both class and instance model references.\n\n        The returned admin class can be modified to customize various aspects\n        of the admin interface. See Django's ModelAdmin documentation for all\n        available options.\n\n        Args:\n            model: The model to get the admin class for\n\n        Returns:\n            The admin class for the model\n\n        Raises:\n            KeyError: If the model is not found in the registered classes\n\n        Example Usage:\n            admin_class = registrar.return_admin_class_for_model(MyModel)\n            admin_class.list_filter += [\"is_custom_component\", \"category\"]\n            admin_class.show_full_result_count = False\n            admin_class.paginator = TimeLimitedPaginator\n\n        \"\"\"\n        model_class = cast(\"type[models.Model]\", model if isinstance(model, type) else model.__class__)\n        registered_instance = admin.site._registry.get(model_class)\n\n        if registered_instance:\n            return registered_instance\n        msg = f\"Model {model_class} not found in registered classes - please register the model first.\"\n        raise KeyError(msg)\n\n    def append_inline(\n        self,\n        model: InclusiveModelType,\n        inline_class: type[admin.TabularInline | admin.StackedInline],\n    ) -&gt; None:\n        \"\"\"\n        Add an inline class to a model's admin.\n\n        This method:\n        1. Gets or creates the inlines list\n        2. Converts tuple to list if needed\n        3. Appends the new inline\n        4. Updates both admin class and registered instance\n\n        Args:\n            model: The model to add the inline to\n            inline_class: The inline class to add\n\n        \"\"\"\n        admin_class = self.return_admin_class_for_model(model)\n\n        # Initialize or convert inlines to list\n        if not hasattr(admin_class, \"inlines\"):\n            admin_class.inlines = []\n        elif isinstance(admin_class.inlines, tuple):\n            admin_class.inlines = list(admin_class.inlines)\n\n        # Add inline if not already present\n        if inline_class not in admin_class.inlines:\n            admin_class.inlines.append(inline_class)\n\n        self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.__init__","title":"<code>__init__(app_label=None, app_labels=None, auto_discover=False)</code>   <p>Initialize the registrar for specific Django app(s).</p> <p>Parameters:</p>    Name Type Description Default      <code>app_label</code>   <code>str</code>    <p>The label of a single Django app to register models for.</p>    <code>None</code>     <code>app_labels</code>   <code>List[str]</code>    <p>List of Django app labels to register models for.</p>    <code>None</code>     <code>auto_discover</code>   <code>bool</code>    <p>Whether to auto-discover and register all installed apps.</p>    <code>False</code>      Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def __init__(self, app_label: str | None = None, app_labels: list[str] | None = None, auto_discover: bool = False):\n    \"\"\"\n    Initialize the registrar for specific Django app(s).\n\n    Args:\n        app_label (str, optional): The label of a single Django app to register models for.\n        app_labels (List[str], optional): List of Django app labels to register models for.\n        auto_discover (bool): Whether to auto-discover and register all installed apps.\n\n    \"\"\"\n    self.class_dict: dict[str, tuple[InclusiveModelType, AdminClassType]] = {}\n    self.app_labels = self._determine_app_labels(app_label, app_labels, auto_discover)\n    self.do_not_register_filter_string_list = app_settings.DEFAULT_DO_NOT_REGISTER_FILTER_STRING_LIST\n    self.models = []\n    self._collect_models()\n    self.model_iterator()\n    self.register_models()\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.add_admin_method","title":"<code>add_admin_method(model, method_name, method_func, *, short_description=None, is_action=False)</code>   <p>Add a method to the admin class for a model.</p> <p>This method allows adding custom methods to the admin class, optionally marking them as actions and setting their short descriptions.</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>InclusiveModelType</code>    <p>The model to add the method to</p>    required     <code>method_name</code>   <code>str</code>    <p>The name to give the method</p>    required     <code>method_func</code>   <code>Callable</code>    <p>The method to add (should be a function)</p>    required     <code>short_description</code>   <code>str | None</code>    <p>Optional description for the method in admin interface</p>    <code>None</code>     <code>is_action</code>   <code>bool</code>    <p>Whether to add this method to the actions list</p>    <code>False</code>      Example <p>def mark_as_special(modeladmin, request, queryset):     queryset.update(is_special=True)</p> <p>registrar.add_admin_method(     MyModel,     \"mark_as_special\",     mark_as_special,     short_description=\"Mark selected items as special\",     is_action=True )</p>   Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def add_admin_method(\n    self,\n    model: InclusiveModelType,\n    method_name: str,\n    method_func: Callable,\n    *,\n    short_description: str | None = None,\n    is_action: bool = False,\n) -&gt; None:\n    \"\"\"\n    Add a method to the admin class for a model.\n\n    This method allows adding custom methods to the admin class, optionally\n    marking them as actions and setting their short descriptions.\n\n    Args:\n        model: The model to add the method to\n        method_name: The name to give the method\n        method_func: The method to add (should be a function)\n        short_description: Optional description for the method in admin interface\n        is_action: Whether to add this method to the actions list\n\n    Example:\n        def mark_as_special(modeladmin, request, queryset):\n            queryset.update(is_special=True)\n\n        registrar.add_admin_method(\n            MyModel,\n            \"mark_as_special\",\n            mark_as_special,\n            short_description=\"Mark selected items as special\",\n            is_action=True\n        )\n\n    \"\"\"\n    # Validate method_name\n    if not method_name or not isinstance(method_name, str):\n        raise ValueError(\"method_name must be a non-empty string\")\n\n    # Validate method_func\n    if method_func is None:\n        raise ValueError(\"method_func cannot be None\")\n\n    # Validate method_name format (should be a valid Python identifier)\n    if not method_name.replace(\"_\", \"\").isalnum() or method_name[0].isdigit():\n        raise ValueError(\"method_name must be a valid Python identifier\")\n\n    admin_instance = self.return_admin_class_for_model(model)  # This is the actual live instance\n\n    final_wrapped_method: Callable\n    if is_action:\n        # Wrapper for admin actions\n        # method_func signature: (modeladmin_instance, request, queryset)\n        # Django calls action as: func(modeladmin, request, queryset)\n        # This wrapper ensures the original method_func is called correctly.\n        def action_wrapper(modeladmin_param, request_param, queryset_param):\n            return method_func(modeladmin_param, request_param, queryset_param)\n\n        final_wrapped_method = action_wrapper\n    else:\n        # Wrapper for display methods (e.g., in list_display)\n        # method_func signature: (modeladmin_instance, model_instance)\n        # Django calls display method as: admin_instance.method_name(model_instance)\n        # 'admin_instance' (the live model admin instance) is available from the outer scope.\n        def display_wrapper(obj_param):  # obj_param is the model_instance passed by Django\n            # admin_instance is the ModelAdmin instance captured from the outer scope of add_admin_method\n            return method_func(admin_instance, obj_param)\n\n        final_wrapped_method = display_wrapper\n\n    # Set the wrapped method directly on the admin instance\n    setattr(admin_instance, method_name, final_wrapped_method)\n\n    # Set short description if provided (on the final_wrapped_method)\n    if short_description:\n        try:\n            final_wrapped_method.short_description = short_description\n        except AttributeError:\n            logger.warning(f\"Could not set short_description on wrapped method {method_name} for model {model}\")\n\n    # Add to actions if requested\n    if is_action:\n        existing_actions = list(getattr(admin_instance, \"actions\", []) or [])\n        action_to_add = final_wrapped_method  # Add the callable wrapper\n\n        already_present = False\n        for existing_action in existing_actions:\n            if existing_action == action_to_add:\n                already_present = True\n                break\n            # Compare by name if functions are different instances but represent the same action\n            if hasattr(existing_action, \"__name__\") and existing_action.__name__ == getattr(\n                action_to_add,\n                \"__name__\",\n                None,\n            ):\n                already_present = True\n                break\n\n        if not already_present:\n            existing_actions.append(action_to_add)\n        admin_instance.actions = existing_actions\n\n    # Sync the changes to the registered instance\n    self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.append_filter_display","title":"<code>append_filter_display(model, list_filter)</code>   <p>Add filter fields to the admin display.</p> <p>This method adds fields to the list_filter property of the admin class. It follows the same pattern as list_display management: 1. Validates fields exist on the model 2. Maintains field order while preventing duplicates 3. Updates both admin class and registered instance</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>type[Model] | Model | PolymorphicModelBase</code>    <p>The model to add filters to</p>    required     <code>list_filter</code>   <code>list[str] | tuple[str]</code>    <p>List or tuple of field names to add as filters</p>    required     <p>Raises:</p>    Type Description      <code>KeyError</code>    <p>If model not found in registered classes</p>      <code>FieldDoesNotExist</code>    <p>If field doesn't exist on model</p>       Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def append_filter_display(\n    self,\n    model: type[models.Model] | models.Model | PolymorphicModelBase,\n    list_filter: list[str] | tuple[str],\n) -&gt; None:\n    \"\"\"\n    Add filter fields to the admin display.\n\n    This method adds fields to the list_filter property of the admin class.\n    It follows the same pattern as list_display management:\n    1. Validates fields exist on the model\n    2. Maintains field order while preventing duplicates\n    3. Updates both admin class and registered instance\n\n    Args:\n        model: The model to add filters to\n        list_filter: List or tuple of field names to add as filters\n\n    Raises:\n        KeyError: If model not found in registered classes\n        FieldDoesNotExist: If field doesn't exist on model\n\n    \"\"\"\n    admin_class = self.return_admin_class_for_model(model)\n    if hasattr(admin_class, \"list_filter\"):\n        # Pass admin_class to verification (assuming list_filter items should also be valid fields/methods)\n        self._verify_list_display_in_model(model, list_filter, admin_class)\n        admin_class.list_filter = self._tuple_list_handler(admin_class.list_filter)\n        # Ensure no duplicates are added\n        for item in list_filter:\n            if item not in admin_class.list_filter:\n                admin_class.list_filter.append(item)\n        self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.append_inline","title":"<code>append_inline(model, inline_class)</code>   <p>Add an inline class to a model's admin.</p> <p>This method: 1. Gets or creates the inlines list 2. Converts tuple to list if needed 3. Appends the new inline 4. Updates both admin class and registered instance</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>InclusiveModelType</code>    <p>The model to add the inline to</p>    required     <code>inline_class</code>   <code>type[TabularInline | StackedInline]</code>    <p>The inline class to add</p>    required      Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def append_inline(\n    self,\n    model: InclusiveModelType,\n    inline_class: type[admin.TabularInline | admin.StackedInline],\n) -&gt; None:\n    \"\"\"\n    Add an inline class to a model's admin.\n\n    This method:\n    1. Gets or creates the inlines list\n    2. Converts tuple to list if needed\n    3. Appends the new inline\n    4. Updates both admin class and registered instance\n\n    Args:\n        model: The model to add the inline to\n        inline_class: The inline class to add\n\n    \"\"\"\n    admin_class = self.return_admin_class_for_model(model)\n\n    # Initialize or convert inlines to list\n    if not hasattr(admin_class, \"inlines\"):\n        admin_class.inlines = []\n    elif isinstance(admin_class.inlines, tuple):\n        admin_class.inlines = list(admin_class.inlines)\n\n    # Add inline if not already present\n    if inline_class not in admin_class.inlines:\n        admin_class.inlines.append(inline_class)\n\n    self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.append_list_display","title":"<code>append_list_display(model, list_display)</code>   <p>Add fields to the end of the admin display list.</p> <p>This method: 1. Validates that all fields exist on the model 2. Maintains field order while preventing duplicates 3. Updates both the admin class and registered instance</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>InclusiveModelType</code>    <p>The model to modify the admin display for</p>    required     <code>list_display</code>   <code>list[str] | tuple[str]</code>    <p>Fields to add to the display list</p>    required      Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def append_list_display(\n    self,\n    model: InclusiveModelType,\n    list_display: list[str] | tuple[str],\n) -&gt; None:\n    \"\"\"\n    Add fields to the end of the admin display list.\n\n    This method:\n    1. Validates that all fields exist on the model\n    2. Maintains field order while preventing duplicates\n    3. Updates both the admin class and registered instance\n\n    Args:\n        model: The model to modify the admin display for\n        list_display: Fields to add to the display list\n\n    \"\"\"\n    admin_class = self.return_admin_class_for_model(model)\n    if hasattr(admin_class, \"list_display\"):\n        # Pass admin_class to verification\n        self._verify_list_display_in_model(model, list_display, admin_class)\n        current_list = self._tuple_list_handler(admin_class.list_display)\n        # Add new fields, avoiding duplicates\n        for field in list_display:\n            if field not in current_list:\n                current_list.append(field)\n        admin_class.list_display = current_list\n        self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.model_iterator","title":"<code>model_iterator()</code>   <p>Iterates through models and creates the associated admin class. Convenience method to create admin classes for models without having to explicitly create them in each app's admin.py file.</p>  Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def model_iterator(self):\n    \"\"\"\n    Iterates through models and creates the associated admin class.\n    Convenience method to create admin classes for models without\n    having to explicitly create them in each app's admin.py file.\n    \"\"\"\n    for model in self.models:\n        model_name = model.__name__ if isinstance(model, type) else model.__class__.__name__\n        model_passes_filter = not any(x in model_name for x in self.do_not_register_filter_string_list)\n        if model._meta.abstract is False and model_passes_filter:\n            admin_class = self._admin_class_factory(model, admin.site)\n            self.class_dict[str(model)] = (model, admin_class)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.prepend_list_display","title":"<code>prepend_list_display(model, list_display)</code>   <p>Add fields to the start of the admin display list.</p> <p>This method: 1. Validates that all fields exist on the model 2. Removes any existing instances of the fields 3. Prepends fields to the start of the list 4. Updates both the admin class and registered instance</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>InclusiveModelType</code>    <p>The model to modify the admin display for</p>    required     <code>list_display</code>   <code>str | list[str] | tuple[str]</code>    <p>Field(s) to add to the start of the display list.          Can be a single string or list/tuple of strings.</p>    required      Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def prepend_list_display(\n    self,\n    model: InclusiveModelType,\n    list_display: str | list[str] | tuple[str],\n) -&gt; None:\n    \"\"\"\n    Add fields to the start of the admin display list.\n\n    This method:\n    1. Validates that all fields exist on the model\n    2. Removes any existing instances of the fields\n    3. Prepends fields to the start of the list\n    4. Updates both the admin class and registered instance\n\n    Args:\n        model: The model to modify the admin display for\n        list_display: Field(s) to add to the start of the display list.\n                     Can be a single string or list/tuple of strings.\n\n    \"\"\"\n    admin_class = self.return_admin_class_for_model(model)\n    if hasattr(admin_class, \"list_display\"):\n        # Convert single string to list\n        fields_to_add = [list_display] if isinstance(list_display, str) else list(list_display)\n\n        # Pass admin_class to verification\n        self._verify_list_display_in_model(model, fields_to_add, admin_class)\n        current_list = self._tuple_list_handler(admin_class.list_display)\n\n        # Remove any existing instances of the fields\n        for field in fields_to_add:\n            if field in current_list:\n                current_list.remove(field)\n\n        # Add new fields at the start\n        for field in reversed(fields_to_add):\n            current_list.insert(0, field)\n\n        admin_class.list_display = current_list\n        self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.register_all_discovered_apps","title":"<code>register_all_discovered_apps()</code>  <code>classmethod</code>    <p>Class method to create a registrar that auto-discovers and registers all apps.</p> <p>This is useful for users who want to register all their models automatically without specifying individual app labels.</p> <p>Returns:</p>    Type Description      <code>AdminModelRegistrar</code>    <p>AdminModelRegistrar instance configured for auto-discovery</p>       Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>@classmethod\ndef register_all_discovered_apps(cls) -&gt; \"AdminModelRegistrar\":\n    \"\"\"\n    Class method to create a registrar that auto-discovers and registers all apps.\n\n    This is useful for users who want to register all their models automatically\n    without specifying individual app labels.\n\n    Returns:\n        AdminModelRegistrar instance configured for auto-discovery\n\n    \"\"\"\n    return cls(auto_discover=True)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.register_app","title":"<code>register_app(app_label)</code>  <code>classmethod</code>    <p>Class method to create a registrar for a single app.</p> <p>Parameters:</p>    Name Type Description Default      <code>app_label</code>   <code>str</code>    <p>The app label to register</p>    required     <p>Returns:</p>    Type Description      <code>AdminModelRegistrar</code>    <p>AdminModelRegistrar instance configured for the specified app</p>       Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>@classmethod\ndef register_app(cls, app_label: str) -&gt; \"AdminModelRegistrar\":\n    \"\"\"\n    Class method to create a registrar for a single app.\n\n    Args:\n        app_label: The app label to register\n\n    Returns:\n        AdminModelRegistrar instance configured for the specified app\n\n    \"\"\"\n    return cls(app_label=app_label)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.register_apps","title":"<code>register_apps(app_labels)</code>  <code>classmethod</code>    <p>Class method to create a registrar for specific app labels.</p> <p>Parameters:</p>    Name Type Description Default      <code>app_labels</code>   <code>list[str]</code>    <p>List of app labels to register</p>    required     <p>Returns:</p>    Type Description      <code>AdminModelRegistrar</code>    <p>AdminModelRegistrar instance configured for the specified apps</p>       Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>@classmethod\ndef register_apps(cls, app_labels: list[str]) -&gt; \"AdminModelRegistrar\":\n    \"\"\"\n    Class method to create a registrar for specific app labels.\n\n    Args:\n        app_labels: List of app labels to register\n\n    Returns:\n        AdminModelRegistrar instance configured for the specified apps\n\n    \"\"\"\n    return cls(app_labels=app_labels)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.register_models","title":"<code>register_models()</code>   <p>Register models with the Django admin site.</p> <p>This method handles the registration process for all models in the app. It ensures that: 1. Each model gets the correct admin class type (regular or polymorphic) 2. List display and filter properties are properly initialized</p>  Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def register_models(self):\n    \"\"\"\n    Register models with the Django admin site.\n\n    This method handles the registration process for all models in the app.\n    It ensures that:\n    1. Each model gets the correct admin class type (regular or polymorphic)\n    2. List display and filter properties are properly initialized\n    \"\"\"\n    if not self.class_dict:\n        logger.debug(f\"No admin classes to register for app {self.app_labels}\")\n        return\n\n    # Ensure any explicit app admin.py registrations are loaded first\n    try:\n        from django.contrib.admin import autodiscover as admin_autodiscover\n\n        admin_autodiscover()\n    except Exception:\n        # Autodiscover may be already executed or unavailable in certain contexts\n        pass\n\n    for name, model_adminclass_tuple in self.class_dict.items():\n        logger.debug(f\"Registering model {name}\")\n        model, admin_class = model_adminclass_tuple\n        # Skip registration if already registered by third-party/admin.py\n        try:\n            if admin.site.is_registered(model):  # type: ignore[attr-defined]\n                logger.info(f\"Model {model} already registered; skipping auto-registration\")\n                self._sync_admin_instance(model)\n                continue\n        except Exception:\n            # Fallback to trying and catching AlreadyRegistered\n            pass\n\n        try:\n            admin.site.register(model, admin_class)  # type: ignore\n            self._sync_admin_instance(model)\n        except AlreadyRegistered:\n            # If already registered, sync the instance\n            self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.return_admin_class_for_model","title":"<code>return_admin_class_for_model(model)</code>   <p>Return the admin class for a model.</p> <p>This method retrieves the admin class associated with a model from the class dictionary. It handles both class and instance model references.</p> <p>The returned admin class can be modified to customize various aspects of the admin interface. See Django's ModelAdmin documentation for all available options.</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>InclusiveModelType</code>    <p>The model to get the admin class for</p>    required     <p>Returns:</p>    Type Description         <p>The admin class for the model</p>      <p>Raises:</p>    Type Description      <code>KeyError</code>    <p>If the model is not found in the registered classes</p>       Example Usage <p>admin_class = registrar.return_admin_class_for_model(MyModel) admin_class.list_filter += [\"is_custom_component\", \"category\"] admin_class.show_full_result_count = False admin_class.paginator = TimeLimitedPaginator</p>   Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def return_admin_class_for_model(self, model: InclusiveModelType):\n    \"\"\"\n    Return the admin class for a model.\n\n    This method retrieves the admin class associated with a model from the\n    class dictionary. It handles both class and instance model references.\n\n    The returned admin class can be modified to customize various aspects\n    of the admin interface. See Django's ModelAdmin documentation for all\n    available options.\n\n    Args:\n        model: The model to get the admin class for\n\n    Returns:\n        The admin class for the model\n\n    Raises:\n        KeyError: If the model is not found in the registered classes\n\n    Example Usage:\n        admin_class = registrar.return_admin_class_for_model(MyModel)\n        admin_class.list_filter += [\"is_custom_component\", \"category\"]\n        admin_class.show_full_result_count = False\n        admin_class.paginator = TimeLimitedPaginator\n\n    \"\"\"\n    model_class = cast(\"type[models.Model]\", model if isinstance(model, type) else model.__class__)\n    registered_instance = admin.site._registry.get(model_class)\n\n    if registered_instance:\n        return registered_instance\n    msg = f\"Model {model_class} not found in registered classes - please register the model first.\"\n    raise KeyError(msg)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.update_list_select_related","title":"<code>update_list_select_related(model, list_select_related)</code>   <p>Update the list_select_related property for a model's admin class.</p> <p>This method allows setting the list_select_related property to optimize database queries for the admin changelist view. It can be: - True: Select all foreign key relationships - False: Don't use any JOINs - List/tuple of field names: Only JOIN the specified relationships</p> <p>Parameters:</p>    Name Type Description Default      <code>model</code>   <code>InclusiveModelType</code>    <p>The model whose admin class should be updated</p>    required     <code>list_select_related</code>   <code>list[str] | tuple[str, ...] | bool</code>    <p>The value to set for list_select_related</p>    required      Example   Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>def update_list_select_related(\n    self,\n    model: InclusiveModelType,\n    list_select_related: list[str] | tuple[str, ...] | bool,\n) -&gt; None:\n    \"\"\"\n    Update the list_select_related property for a model's admin class.\n\n    This method allows setting the list_select_related property to optimize\n    database queries for the admin changelist view. It can be:\n    - True: Select all foreign key relationships\n    - False: Don't use any JOINs\n    - List/tuple of field names: Only JOIN the specified relationships\n\n    Args:\n        model: The model whose admin class should be updated\n        list_select_related: The value to set for list_select_related\n\n    Example:\n        # To select all foreign keys\n        registrar.update_list_select_related(MyModel, True)\n\n        # To select specific foreign keys\n        registrar.update_list_select_related(MyModel, ['author', 'category'])\n\n        # To disable all automatic JOINs\n        registrar.update_list_select_related(MyModel, False)\n\n    \"\"\"\n    admin_class = self.return_admin_class_for_model(model)\n    admin_class.list_select_related = list_select_related\n    self._sync_admin_instance(model)\n</code></pre>","text":""},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.update_list_select_related--to-select-all-foreign-keys","title":"To select all foreign keys","text":"<p>registrar.update_list_select_related(MyModel, True)</p>"},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.update_list_select_related--to-select-specific-foreign-keys","title":"To select specific foreign keys","text":"<p>registrar.update_list_select_related(MyModel, ['author', 'category'])</p>"},{"location":"reference/registrar/#django_admin_magic.registrar.AdminModelRegistrar.update_list_select_related--to-disable-all-automatic-joins","title":"To disable all automatic JOINs","text":"<p>registrar.update_list_select_related(MyModel, False)</p>"},{"location":"reference/registrar/#django_admin_magic.registrar.NoOpRegistrar","title":"<code>NoOpRegistrar</code>","text":"<p>Registrar that performs no operations.</p> <p>Used when auto-registration is disabled (e.g., during migrations or when admin is not installed). Provides the same API surface as the real registrar but all methods are safe no-ops to avoid import-time side effects.</p> Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>class NoOpRegistrar:\n    \"\"\"\n    Registrar that performs no operations.\n\n    Used when auto-registration is disabled (e.g., during migrations or when admin\n    is not installed). Provides the same API surface as the real registrar but\n    all methods are safe no-ops to avoid import-time side effects.\n    \"\"\"\n\n    def __init__(self, app_label: str | None = None, app_labels: list[str] | None = None, auto_discover: bool = False):\n        self.app_labels = []\n\n    @classmethod\n    def register_all_discovered_apps(cls) -&gt; \"NoOpRegistrar\":\n        return cls(auto_discover=True)\n\n    @classmethod\n    def register_apps(cls, app_labels: list[str]) -&gt; \"NoOpRegistrar\":\n        return cls(app_labels=app_labels)\n\n    @classmethod\n    def register_app(cls, app_label: str) -&gt; \"NoOpRegistrar\":\n        return cls(app_label=app_label)\n\n    # Common mutator methods are implemented as no-ops\n    def register_models(self):\n        return None\n\n    def return_admin_class_for_model(self, model: InclusiveModelType):\n        raise KeyError(\"Auto admin registration is disabled; no admin classes are available.\")\n\n    def add_search_fields(self, *args, **kwargs):\n        return None\n\n    def append_list_display(self, *args, **kwargs):\n        return None\n\n    def prepend_list_display(self, *args, **kwargs):\n        return None\n\n    def remove_list_display(self, *args, **kwargs):\n        return None\n\n    def append_filter_display(self, *args, **kwargs):\n        return None\n\n    def append_inline(self, *args, **kwargs):\n        return None\n</code></pre>"},{"location":"reference/registrar/#django_admin_magic.registrar.PolymorphicAdminModelRegistrar","title":"<code>PolymorphicAdminModelRegistrar</code>","text":"<p>               Bases: <code>AdminModelRegistrar</code></p> <p>An extension of AdminModelRegistrar that handles polymorphic models.</p> Source code in <code>src/django_admin_magic/registrar.py</code> <pre><code>class PolymorphicAdminModelRegistrar(AdminModelRegistrar):\n    \"\"\"An extension of AdminModelRegistrar that handles polymorphic models.\"\"\"\n\n    def _admin_class_factory(self, model, admin_site):\n        \"\"\"\n        Creates class prototypes for admin_classes depending on the incoming model object.\n        This method handles both regular and polymorphic models.\n        \"\"\"\n        adminclass_name = f\"AdminClass_{model.__name__}\"\n        common_class_kwargs = {\"model\": model, \"admin_site\": admin_site}\n        if is_polymorphic_model(model):\n            if is_polymorphic_model_parent_model(model):\n                return type(\n                    adminclass_name,\n                    (PolymorphicParentListAdmin,),\n                    common_class_kwargs,\n                )\n            return type(\n                adminclass_name,\n                (PolymorphicChildListAdmin,),\n                common_class_kwargs,\n            )\n        return super()._admin_class_factory(model, admin_site)\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#django_admin_magic.utils.TimeLimitedPaginator","title":"<code>TimeLimitedPaginator</code>","text":"<p>               Bases: <code>Paginator</code></p> <p>Paginator that enforces a timeout on the count operation. If the operations times out, a fake bogus value is returned instead.</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>class TimeLimitedPaginator(Paginator):\n    \"\"\"\n    Paginator that enforces a timeout on the count operation.\n    If the operations times out, a fake bogus value is\n    returned instead.\n    \"\"\"\n\n    def __init__(self, object_list, per_page, orphans=0, allow_empty_first_page=True):\n        # Validate per_page\n        if per_page is not None and (not isinstance(per_page, int) or per_page &lt;= 0):\n            raise ValueError(\"per_page must be a positive integer or None\")\n        super().__init__(object_list, per_page, orphans, allow_empty_first_page)\n\n    @cached_property\n    def count(self):\n        # We set the timeout in a db transaction to prevent it from\n        # affecting other transactions.\n        try:\n            with transaction.atomic(), connection.cursor() as cursor:\n                # Only set statement_timeout for PostgreSQL\n                if connection.vendor == \"postgresql\":\n                    cursor.execute(\"SET LOCAL statement_timeout TO 1000;\")\n                return super().count\n        except OperationalError:\n            with transaction.atomic(), connection.cursor() as cursor:\n                # Obtain estimated values (only valid with PostgreSQL)\n                if not self.object_list.query.model:  # type: ignore\n                    raise\n\n                # Only use PostgreSQL-specific query for PostgreSQL\n                if connection.vendor == \"postgresql\":\n                    cursor.execute(\n                        \"SELECT reltuples FROM pg_class WHERE relname = %s\",\n                        [self.object_list.query.model._meta.db_table],  # type: ignore\n                    )\n                    res = cursor.fetchone()\n                    if res:\n                        return int(res[0])\n\n                # For non-PostgreSQL databases, return a reasonable estimate\n                # or fall back to the actual count (which might be slow)\n                logger.warning(\n                    f\"Count operation failed for {self.object_list.query.model._meta.db_table}. \"\n                    f\"Database vendor: {connection.vendor}. Falling back to actual count.\"\n                )\n                return super().count\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.autoreg_disabled","title":"<code>autoreg_disabled()</code>","text":"<p>Determine whether auto admin registration should be disabled for the current context.</p> <p>Disables for: - Explicit project setting/env flag - Migrations (makemigrations/migrate) and other configured skip commands - When django.contrib.admin is not installed and configured to skip</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def autoreg_disabled() -&gt; bool:\n    \"\"\"\n    Determine whether auto admin registration should be disabled for the current context.\n\n    Disables for:\n    - Explicit project setting/env flag\n    - Migrations (makemigrations/migrate) and other configured skip commands\n    - When django.contrib.admin is not installed and configured to skip\n    \"\"\"\n    # Explicit setting toggle\n    try:\n        if getattr(app_settings, \"DISABLED\", False):\n            return True\n    except Exception:\n        # If settings are not ready, continue with other checks\n        pass\n\n    # Environment variable overrides\n    if os.environ.get(\"DJANGO_ADMIN_MAGIC_DISABLE\") == \"1\" or os.environ.get(\"AUTO_ADMIN_DISABLE\") == \"1\":\n        return True\n\n    # Skip specific management commands\n    cmd = sys.argv[1] if len(sys.argv) &gt; 1 else \"\"\n    skip_commands = set(getattr(app_settings, \"SKIP_COMMANDS\", []))\n    if cmd in skip_commands:\n        return True\n\n    # Skip when admin not installed (based on config)\n    try:\n        if getattr(app_settings, \"SKIP_IF_ADMIN_NOT_INSTALLED\", True) and not django_apps.is_installed(\n            \"django.contrib.admin\"\n        ):\n            return True\n    except Exception:\n        # apps registry may not be ready yet; fallback to settings\n        try:\n            from django.conf import settings as dj_settings\n\n            if getattr(app_settings, \"SKIP_IF_ADMIN_NOT_INSTALLED\", True) and (\n                not hasattr(dj_settings, \"INSTALLED_APPS\") or \"django.contrib.admin\" not in dj_settings.INSTALLED_APPS\n            ):\n                return True\n        except Exception:\n            pass\n\n    return False\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar","title":"<code>create_auto_admin_registrar(app_label=None)</code>","text":"<p>Create an auto admin registrar for the current app.</p> <p>This function is designed to be used in admin.py files to automatically register all models in the current app with the admin site.</p> <p>Parameters:</p> Name Type Description Default <code>app_label</code> <code>str</code> <p>The app label to register. If None, will be                      automatically determined from the current package.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AdminModelRegistrar</code> <p>The registrar instance</p> Example Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def create_auto_admin_registrar(app_label: str = None):\n    \"\"\"\n    Create an auto admin registrar for the current app.\n\n    This function is designed to be used in admin.py files to automatically\n    register all models in the current app with the admin site.\n\n    Args:\n        app_label (str, optional): The app label to register. If None, will be\n                                 automatically determined from the current package.\n\n    Returns:\n        AdminModelRegistrar: The registrar instance\n\n    Example:\n        # In your app's admin.py file:\n        from django_admin_magic.utils import create_auto_admin_registrar\n\n        registrar = create_auto_admin_registrar()\n        # All models in this app are now registered with the admin site\n\n    \"\"\"\n    from .registrar import AdminModelRegistrar, NoOpRegistrar\n\n    if autoreg_disabled():\n        return NoOpRegistrar()\n\n    inferred_app_label = app_label\n    if inferred_app_label is None:\n        inferred_app_label = infer_current_app_label()\n\n    if not inferred_app_label:\n        logger.debug(\"Unable to infer app label for auto admin registrar; skipping registration.\")\n        return NoOpRegistrar()\n\n    return AdminModelRegistrar.register_app(inferred_app_label)\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar--in-your-apps-adminpy-file","title":"In your app's admin.py file:","text":"<p>from django_admin_magic.utils import create_auto_admin_registrar</p> <p>registrar = create_auto_admin_registrar()</p>"},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar--all-models-in-this-app-are-now-registered-with-the-admin-site","title":"All models in this app are now registered with the admin site","text":""},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar_for_all_apps","title":"<code>create_auto_admin_registrar_for_all_apps()</code>","text":"<p>Create an auto admin registrar that discovers and registers all apps.</p> <p>Returns:</p> Name Type Description <code>AdminModelRegistrar</code> <p>The registrar instance</p> Example Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def create_auto_admin_registrar_for_all_apps():\n    \"\"\"\n    Create an auto admin registrar that discovers and registers all apps.\n\n    Returns:\n        AdminModelRegistrar: The registrar instance\n\n    Example:\n        # In your admin.py file:\n        from django_admin_magic.utils import create_auto_admin_registrar_for_all_apps\n\n        registrar = create_auto_admin_registrar_for_all_apps()\n\n    \"\"\"\n    from .registrar import AdminModelRegistrar, NoOpRegistrar\n\n    if autoreg_disabled():\n        return NoOpRegistrar()\n\n    return AdminModelRegistrar.register_all_discovered_apps()\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar_for_all_apps--in-your-adminpy-file","title":"In your admin.py file:","text":"<p>from django_admin_magic.utils import create_auto_admin_registrar_for_all_apps</p> <p>registrar = create_auto_admin_registrar_for_all_apps()</p>"},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar_for_apps","title":"<code>create_auto_admin_registrar_for_apps(app_labels)</code>","text":"<p>Create an auto admin registrar for multiple apps.</p> <p>Parameters:</p> Name Type Description Default <code>app_labels</code> <code>list[str]</code> <p>List of app labels to register</p> required <p>Returns:</p> Name Type Description <code>AdminModelRegistrar</code> <p>The registrar instance</p> Example Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def create_auto_admin_registrar_for_apps(app_labels: list[str]):\n    \"\"\"\n    Create an auto admin registrar for multiple apps.\n\n    Args:\n        app_labels (list[str]): List of app labels to register\n\n    Returns:\n        AdminModelRegistrar: The registrar instance\n\n    Example:\n        # In your admin.py file:\n        from django_admin_magic.utils import create_auto_admin_registrar_for_apps\n\n        registrar = create_auto_admin_registrar_for_apps(['myapp1', 'myapp2'])\n\n    \"\"\"\n    from .registrar import AdminModelRegistrar, NoOpRegistrar\n\n    if autoreg_disabled():\n        return NoOpRegistrar()\n\n    return AdminModelRegistrar.register_apps(app_labels)\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.create_auto_admin_registrar_for_apps--in-your-adminpy-file","title":"In your admin.py file:","text":"<p>from django_admin_magic.utils import create_auto_admin_registrar_for_apps</p> <p>registrar = create_auto_admin_registrar_for_apps(['myapp1', 'myapp2'])</p>"},{"location":"reference/utils/#django_admin_magic.utils.get_all_child_classes","title":"<code>get_all_child_classes(cls)</code>","text":"<p>Recursively retrieves all child classes of a given class.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type</code> <p>The class to inspect for child classes.</p> required <p>Returns:</p> Type Description <code>list[type]</code> <p>List[Type]: A list of all direct and indirect subclasses of the given class.</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def get_all_child_classes(cls: type) -&gt; list[type]:\n    \"\"\"\n    Recursively retrieves all child classes of a given class.\n\n    Args:\n        cls (Type): The class to inspect for child classes.\n\n    Returns:\n        List[Type]: A list of all direct and indirect subclasses of the given class.\n\n    \"\"\"\n    child_classes = cls.__subclasses__()  # Get direct subclasses\n    all_children = child_classes[:]  # Start with direct subclasses\n\n    for child in child_classes:\n        # Recursively add subclasses of each child\n        all_children.extend(get_all_child_classes(child))\n\n    return all_children\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.infer_current_app_label","title":"<code>infer_current_app_label()</code>","text":"<p>Infer the current Django app label from the caller's module using Django's app registry.</p> <p>This is safer than relying on 'package' which may not be set during certain management commands (e.g., migrations) or when imported in unusual contexts.</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def infer_current_app_label() -&gt; str | None:\n    \"\"\"\n    Infer the current Django app label from the caller's module using Django's app registry.\n\n    This is safer than relying on '__package__' which may not be set during certain\n    management commands (e.g., migrations) or when imported in unusual contexts.\n    \"\"\"\n    module_name = None\n    module = None\n    try:\n        current_frame = inspect.currentframe()\n        if current_frame is not None and current_frame.f_back is not None:\n            module = inspect.getmodule(current_frame.f_back)\n            if module is not None:\n                module_name = module.__name__\n    finally:\n        # Help GC with frame references\n        del current_frame\n\n    if module_name:\n        try:\n            app_config = django_apps.get_containing_app_config(module_name)\n            if app_config is not None:\n                return app_config.label\n        except Exception:\n            pass\n\n        # Fallback: try prefix match with installed app configs\n        for config in django_apps.get_app_configs():\n            if module_name.startswith(config.name):\n                return config.label\n\n    # Secondary fallback using module.__package__ if available\n    try:\n        if module is not None and getattr(module, \"__package__\", None):\n            pkg = module.__package__\n            for config in django_apps.get_app_configs():\n                if pkg.startswith(config.name):\n                    return config.label\n    except Exception:\n        pass\n\n    return None\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.is_linkify_function","title":"<code>is_linkify_function(field)</code>","text":"<p>Check if a field is a linkify function (either linkify or linkify_gfk).</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <p>The field to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the field is a linkify function, False otherwise</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def is_linkify_function(field):\n    \"\"\"\n    Check if a field is a linkify function (either linkify or linkify_gfk).\n\n    Args:\n        field: The field to check\n\n    Returns:\n        bool: True if the field is a linkify function, False otherwise\n\n    \"\"\"\n    if not callable(field):\n        return False\n\n    # Check if it's a linkify function by examining its function name or attributes\n    # Both linkify and linkify_gfk functions have specific patterns\n    func_name = getattr(field, \"__name__\", \"\")\n\n    # Check for the specific function names used in linkify functions\n    if func_name in (\"_linkify\", \"_linkify_gfk\", \"_linkify_m2m\"):\n        return True\n\n    # Additional check: look for the short_description attribute which is set on linkify functions\n    if hasattr(field, \"short_description\") and hasattr(field, \"admin_order_field\"):\n        return True\n\n    # Check if the function was created by our linkify functions by examining the closure\n    try:\n        # Get the function's code object to check if it contains linkify-specific patterns\n        if hasattr(field, \"__code__\"):\n            # This is a more robust way to detect our linkify functions\n            # We can check if the function has the expected attributes\n            if hasattr(field, \"short_description\") and hasattr(field, \"admin_order_field\"):\n                return True\n    except (AttributeError, TypeError):\n        pass\n\n    return False\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.linkify","title":"<code>linkify(field_name)</code>","text":"<p>Converts a foreign key value into clickable links.</p> <p>If field_name is 'parent', link text will be str(obj.parent) Link will be admin url for the admin url for obj.parent.id:change</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def linkify(field_name):\n    \"\"\"\n    Converts a foreign key value into clickable links.\n\n    If field_name is 'parent', link text will be str(obj.parent)\n    Link will be admin url for the admin url for obj.parent.id:change\n    \"\"\"\n\n    def _linkify(obj):\n        linked_obj = getattr(obj, field_name)\n        if linked_obj is None:\n            return \"-\"\n        app_label = linked_obj._meta.app_label\n        model_name = linked_obj._meta.model_name\n        view_name = f\"admin:{app_label}_{model_name}_change\"\n        # Add try-except block for cases where reverse fails (e.g., model not in admin)\n        try:\n            link_url = reverse(view_name, args=[linked_obj.pk])\n            return format_html('&lt;a href=\"{}\"&gt;{}&lt;/a&gt;', link_url, linked_obj)\n        except Exception:\n            # Fallback: Display object representation without a link\n            logger.debug(f\"Could not reverse admin URL for {app_label}.{model_name} with pk {linked_obj.pk}\")\n            return str(linked_obj)\n\n    desc = field_name.replace(\"_\", \" \").title()\n    try:\n        _linkify.short_description = desc  # Sets column name\n        _linkify.admin_order_field = field_name  # Allow sorting by this field\n    except AttributeError:\n        logger.warning(f\"Could not set admin attributes on linkify function for {field_name}\")\n    return _linkify\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.linkify_gfk","title":"<code>linkify_gfk(field_name)</code>","text":"<p>Converts a GenericForeignKey value into clickable links in the admin.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the GenericForeignKey field on the model.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <p>A function suitable for Django admin's list_display.</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def linkify_gfk(field_name):\n    \"\"\"\n    Converts a GenericForeignKey value into clickable links in the admin.\n\n    Args:\n        field_name (str): The name of the GenericForeignKey field on the model.\n\n    Returns:\n        Callable: A function suitable for Django admin's list_display.\n\n    \"\"\"\n\n    def _linkify_gfk(obj):\n        linked_obj = getattr(obj, field_name)\n        if linked_obj is None:\n            return \"-\"\n\n        # GFK target object could be anything, so we need its ContentType info\n        try:\n            # Ensure the linked object has a _meta attribute and pk\n            if not hasattr(linked_obj, \"_meta\") or not hasattr(linked_obj, \"pk\") or linked_obj.pk is None:\n                # Fallback if it's not a standard model instance or has no pk\n                return str(linked_obj)\n\n            # Get metadata directly from the linked object instance\n            obj_id = linked_obj.pk\n            app_label = linked_obj._meta.app_label\n            model_name = linked_obj._meta.model_name\n\n            view_name = f\"admin:{app_label}_{model_name}_change\"\n            link_url = reverse(view_name, args=[obj_id])\n            # Use a simplified representation, perhaps just the model name and PK\n            display_text = f\"{model_name.capitalize()} {obj_id}\"\n            return format_html('&lt;a href=\"{}\"&gt;{}&lt;/a&gt;', link_url, display_text)\n        except Exception as e:\n            # Fallback if URL cannot be reversed or any other error occurs\n            logger.debug(f\"Could not reverse admin URL for GFK target {linked_obj}: {e}\")\n            return str(linked_obj)  # Display the object's string representation\n\n    # Use the GFK field name for description and ordering\n    desc = field_name.replace(\"_\", \" \").title()\n    try:\n        _linkify_gfk.short_description = desc\n        _linkify_gfk.admin_order_field = field_name  # Attempt sorting - may depend on GFK setup\n    except AttributeError:\n        logger.warning(f\"Could not set admin attributes on linkify_gfk function for {field_name}\")\n    return _linkify_gfk\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.linkify_m2m","title":"<code>linkify_m2m(field_name)</code>","text":"<p>Render a ManyToMany field as a comma-separated list of linkified related objects.</p> <ul> <li>Respects configured limit via app settings (M2M_LIST_MAX_ITEMS)</li> <li>Uses configured display attribute (M2M_LIST_DISPLAY_ATTR), defaulting to str</li> <li>Falls back gracefully if admin URL cannot be reversed</li> <li>Clips with an ellipsis when more than the configured limit</li> </ul> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def linkify_m2m(field_name):\n    \"\"\"\n    Render a ManyToMany field as a comma-separated list of linkified related objects.\n\n    - Respects configured limit via app settings (M2M_LIST_MAX_ITEMS)\n    - Uses configured display attribute (M2M_LIST_DISPLAY_ATTR), defaulting to __str__\n    - Falls back gracefully if admin URL cannot be reversed\n    - Clips with an ellipsis when more than the configured limit\n    \"\"\"\n\n    def _resolve_display_text(related_obj):\n        display_attr = getattr(app_settings, \"M2M_LIST_DISPLAY_ATTR\", \"__str__\")\n        if display_attr == \"__str__\":\n            return str(related_obj)\n        # Support dotted path attributes, e.g., \"profile.name\"\n        try:\n            value = related_obj\n            for part in str(display_attr).split(\".\"):\n                value = getattr(value, part)\n            return str(value)\n        except Exception:\n            return str(related_obj)\n\n    def _maybe_link(related_obj, text):\n        try:\n            if not hasattr(related_obj, \"_meta\") or getattr(related_obj, \"pk\", None) is None:\n                return text\n            app_label = related_obj._meta.app_label\n            model_name = related_obj._meta.model_name\n            view_name = f\"admin:{app_label}_{model_name}_change\"\n            link_url = reverse(view_name, args=[related_obj.pk])\n            return format_html('&lt;a href=\"{}\"&gt;{}&lt;/a&gt;', link_url, text)\n        except Exception:\n            return text\n\n    def _linkify_m2m(obj):\n        try:\n            manager = getattr(obj, field_name)\n        except Exception:\n            return \"-\"\n\n        try:\n            queryset = manager.all()\n        except Exception:\n            return \"-\"\n\n        max_items = getattr(app_settings, \"M2M_LIST_MAX_ITEMS\", 10) or 10\n        items = list(queryset[: max_items + 1])\n        has_more = len(items) &gt; max_items\n        items = items[:max_items]\n\n        if not items:\n            return \"-\"\n\n        display_nodes = [_maybe_link(related, _resolve_display_text(related)) for related in items]\n\n        # Join with comma+space safely\n        rendered = (\n            display_nodes[0]\n            if len(display_nodes) == 1\n            else format_html_join(\n                \", \",\n                \"{}\",\n                ((node,) for node in display_nodes),\n            )\n        )\n\n        if has_more:\n            rendered = format_html(\"{}{}\", rendered, \" ...\")\n        return rendered\n\n    desc = field_name.replace(\"_\", \" \").title()\n    try:\n        _linkify_m2m.short_description = desc\n        # M2M not sortable by default\n    except AttributeError:\n        logger.warning(f\"Could not set admin attributes on linkify_m2m for {field_name}\")\n    return _linkify_m2m\n</code></pre>"},{"location":"reference/utils/#django_admin_magic.utils.reorder_list_display_to_avoid_linkify_first","title":"<code>reorder_list_display_to_avoid_linkify_first(list_display)</code>","text":"<p>Reorder list_display to ensure the first field is not a linkify function. Moves all leading linkify functions after the first non-linkify field.</p> Source code in <code>src/django_admin_magic/utils.py</code> <pre><code>def reorder_list_display_to_avoid_linkify_first(list_display):\n    \"\"\"\n    Reorder list_display to ensure the first field is not a linkify function.\n    Moves all leading linkify functions after the first non-linkify field.\n    \"\"\"\n    if not list_display or len(list_display) &lt; 2:\n        return list_display\n\n    # Find the index of the first non-linkify field\n    first_non_linkify_index = None\n    for i, field in enumerate(list_display):\n        if not is_linkify_function(field):\n            first_non_linkify_index = i\n            break\n\n    if first_non_linkify_index is None or first_non_linkify_index == 0:\n        # No non-linkify field found, or already starts with non-linkify\n        return list_display\n\n    # Move all leading linkify functions (from start up to first non-linkify) after the first non-linkify\n    leading_linkify = list_display[:first_non_linkify_index]\n    rest = list_display[first_non_linkify_index:]\n    reordered = [rest[0]] + leading_linkify + rest[1:]\n    logger.debug(f\"Reordered list_display to avoid linkify field being first: {reordered}\")\n    return reordered\n</code></pre>"}]}